/**
 * Original work: Copyright (c) 2014 Sergey Skoblikov
 * Modified work: Copyright (c) 2015-2022 Dmitry Ivanov
 *
 * This file is a part of QEverCloud project and is distributed under the terms
 * of MIT license:
 * https://opensource.org/licenses/MIT
 *
 * This file was generated from Evernote Thrift API
 */

#include "TestNoteStore.h"
#include "../../src/Impl.h"
#include "../ClearLocalIds.h"
#include "../RandomDataGenerators.h"
#include "../SocketHelpers.h"
#include "QEventLoop"
#include <qevercloud/services/INoteStore.h>
#include <qevercloud/services/NoteStoreServer.h>
#include <QFutureWatcher>
#include <QTcpServer>
#include <QtTest/QtTest>

namespace qevercloud {

////////////////////////////////////////////////////////////////////////////////

namespace {

////////////////////////////////////////////////////////////////////////////////

template <class T>
void compareValuesWithoutLocalIds(const T & lhs, const T & rhs)
{
    T lhsCopy = lhs;
    clearLocalIds(lhsCopy);

    T rhsCopy = rhs;
    clearLocalIds(rhsCopy);

    Q_ASSERT(lhsCopy == rhsCopy);
}

template <class T>
void compareListValuesWithoutLocalIds(const QList<T> & lhs, const QList<T> & rhs)
{
    Q_ASSERT(lhs.size() == rhs.size());

    QList<T> lhsCopy = lhs;
    for (auto & v: lhsCopy) {
        clearLocalIds(v);
    }

    QList<T> rhsCopy = rhs;
    for (auto & v: rhsCopy) {
        clearLocalIds(v);
    }

    Q_ASSERT(lhsCopy == rhsCopy);
}

template <class T>
void compareSetValuesWithoutLocalIds(const QSet<T> & lhs, const QSet<T> & rhs)
{
    Q_ASSERT(lhs.size() == rhs.size());

    QSet<T> lhsCopy = lhs;
    for (auto & v: lhsCopy) {
        clearLocalIds(v);
    }

    QSet<T> rhsCopy = rhs;
    for (auto & v: rhsCopy) {
        clearLocalIds(v);
    }

    Q_ASSERT(lhsCopy == rhsCopy);
}

template <class K, class V>
void compareMapValuesWithoutLocalIds(const QMap<K, V> & lhs, const QMap<K, V> & rhs)
{
    Q_ASSERT(lhs.size() == rhs.size());

    QMap<K, V> lhsCopy = lhs;
    for (auto it = lhsCopy.begin(); it != lhsCopy.end(); ++it) {
        clearLocalIds(it.value());
    }

    QMap<K, V> rhsCopy = rhs;
    for (auto it = rhsCopy.begin(); it != rhsCopy.end(); ++it) {
        clearLocalIds(it.value());
    }

    Q_ASSERT(lhsCopy == rhsCopy);
}

} // namespace

////////////////////////////////////////////////////////////////////////////////

NoteStoreTester::NoteStoreTester(QObject * parent) :
    QObject(parent)
{}

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetSyncStateTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SyncState(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetSyncStateTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getSyncStateRequestReady(
        SyncState value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetSyncStateRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT getSyncStateRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getSyncStateRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetFilteredSyncChunkTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SyncChunk(
            qint32,
            qint32,
            const SyncChunkFilter &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetFilteredSyncChunkTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getFilteredSyncChunkRequestReady(
        SyncChunk value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetFilteredSyncChunkRequestReceived(
        qint32 afterUSN,
        qint32 maxEntries,
        SyncChunkFilter filter,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                afterUSN,
                maxEntries,
                filter,
                ctx);

            Q_EMIT getFilteredSyncChunkRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getFilteredSyncChunkRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetLinkedNotebookSyncStateTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SyncState(
            const LinkedNotebook &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetLinkedNotebookSyncStateTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getLinkedNotebookSyncStateRequestReady(
        SyncState value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetLinkedNotebookSyncStateRequestReceived(
        LinkedNotebook linkedNotebook,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                linkedNotebook,
                ctx);

            Q_EMIT getLinkedNotebookSyncStateRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getLinkedNotebookSyncStateRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetLinkedNotebookSyncChunkTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SyncChunk(
            const LinkedNotebook &,
            qint32,
            qint32,
            bool,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetLinkedNotebookSyncChunkTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getLinkedNotebookSyncChunkRequestReady(
        SyncChunk value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetLinkedNotebookSyncChunkRequestReceived(
        LinkedNotebook linkedNotebook,
        qint32 afterUSN,
        qint32 maxEntries,
        bool fullSyncOnly,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                linkedNotebook,
                afterUSN,
                maxEntries,
                fullSyncOnly,
                ctx);

            Q_EMIT getLinkedNotebookSyncChunkRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getLinkedNotebookSyncChunkRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListNotebooksTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<Notebook>(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListNotebooksTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listNotebooksRequestReady(
        QList<Notebook> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListNotebooksRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT listNotebooksRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listNotebooksRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListAccessibleBusinessNotebooksTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<Notebook>(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListAccessibleBusinessNotebooksTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listAccessibleBusinessNotebooksRequestReady(
        QList<Notebook> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListAccessibleBusinessNotebooksRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT listAccessibleBusinessNotebooksRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listAccessibleBusinessNotebooksRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Notebook(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNotebookRequestReady(
        Notebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNotebookRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetDefaultNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Notebook(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetDefaultNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getDefaultNotebookRequestReady(
        Notebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetDefaultNotebookRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT getDefaultNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getDefaultNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreCreateNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Notebook(
            const Notebook &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreCreateNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void createNotebookRequestReady(
        Notebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onCreateNotebookRequestReceived(
        Notebook notebook,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                notebook,
                ctx);

            Q_EMIT createNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT createNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            const Notebook &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateNotebookRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateNotebookRequestReceived(
        Notebook notebook,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                notebook,
                ctx);

            Q_EMIT updateNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreExpungeNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreExpungeNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void expungeNotebookRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onExpungeNotebookRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT expungeNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT expungeNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListTagsTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<Tag>(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListTagsTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listTagsRequestReady(
        QList<Tag> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListTagsRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT listTagsRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listTagsRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListTagsByNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<Tag>(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListTagsByNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listTagsByNotebookRequestReady(
        QList<Tag> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListTagsByNotebookRequestReceived(
        Guid notebookGuid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                notebookGuid,
                ctx);

            Q_EMIT listTagsByNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listTagsByNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetTagTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Tag(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetTagTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getTagRequestReady(
        Tag value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetTagRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getTagRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getTagRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreCreateTagTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Tag(
            const Tag &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreCreateTagTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void createTagRequestReady(
        Tag value,
        std::exception_ptr e);

public Q_SLOTS:
    void onCreateTagRequestReceived(
        Tag tag,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                tag,
                ctx);

            Q_EMIT createTagRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT createTagRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateTagTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            const Tag &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateTagTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateTagRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateTagRequestReceived(
        Tag tag,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                tag,
                ctx);

            Q_EMIT updateTagRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateTagRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUntagAllTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        void(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUntagAllTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void untagAllRequestReady(
        std::exception_ptr e);

public Q_SLOTS:
    void onUntagAllRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            m_executor(
                guid,
                ctx);

            Q_EMIT untagAllRequestReady(
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT untagAllRequestReady(
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreExpungeTagTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreExpungeTagTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void expungeTagRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onExpungeTagRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT expungeTagRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT expungeTagRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListSearchesTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<SavedSearch>(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListSearchesTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listSearchesRequestReady(
        QList<SavedSearch> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListSearchesRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT listSearchesRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listSearchesRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetSearchTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SavedSearch(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetSearchTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getSearchRequestReady(
        SavedSearch value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetSearchRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getSearchRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getSearchRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreCreateSearchTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SavedSearch(
            const SavedSearch &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreCreateSearchTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void createSearchRequestReady(
        SavedSearch value,
        std::exception_ptr e);

public Q_SLOTS:
    void onCreateSearchRequestReceived(
        SavedSearch search,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                search,
                ctx);

            Q_EMIT createSearchRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT createSearchRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateSearchTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            const SavedSearch &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateSearchTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateSearchRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateSearchRequestReceived(
        SavedSearch search,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                search,
                ctx);

            Q_EMIT updateSearchRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateSearchRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreExpungeSearchTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreExpungeSearchTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void expungeSearchRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onExpungeSearchRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT expungeSearchRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT expungeSearchRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreFindNoteOffsetTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            const NoteFilter &,
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreFindNoteOffsetTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void findNoteOffsetRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onFindNoteOffsetRequestReceived(
        NoteFilter filter,
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                filter,
                guid,
                ctx);

            Q_EMIT findNoteOffsetRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT findNoteOffsetRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreFindNotesMetadataTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        NotesMetadataList(
            const NoteFilter &,
            qint32,
            qint32,
            const NotesMetadataResultSpec &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreFindNotesMetadataTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void findNotesMetadataRequestReady(
        NotesMetadataList value,
        std::exception_ptr e);

public Q_SLOTS:
    void onFindNotesMetadataRequestReceived(
        NoteFilter filter,
        qint32 offset,
        qint32 maxNotes,
        NotesMetadataResultSpec resultSpec,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                filter,
                offset,
                maxNotes,
                resultSpec,
                ctx);

            Q_EMIT findNotesMetadataRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT findNotesMetadataRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreFindNoteCountsTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        NoteCollectionCounts(
            const NoteFilter &,
            bool,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreFindNoteCountsTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void findNoteCountsRequestReady(
        NoteCollectionCounts value,
        std::exception_ptr e);

public Q_SLOTS:
    void onFindNoteCountsRequestReceived(
        NoteFilter filter,
        bool withTrash,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                filter,
                withTrash,
                ctx);

            Q_EMIT findNoteCountsRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT findNoteCountsRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteWithResultSpecTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Note(
            Guid,
            const NoteResultSpec &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteWithResultSpecTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteWithResultSpecRequestReady(
        Note value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteWithResultSpecRequestReceived(
        Guid guid,
        NoteResultSpec resultSpec,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                resultSpec,
                ctx);

            Q_EMIT getNoteWithResultSpecRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteWithResultSpecRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Note(
            Guid,
            bool,
            bool,
            bool,
            bool,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteRequestReady(
        Note value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteRequestReceived(
        Guid guid,
        bool withContent,
        bool withResourcesData,
        bool withResourcesRecognition,
        bool withResourcesAlternateData,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                withContent,
                withResourcesData,
                withResourcesRecognition,
                withResourcesAlternateData,
                ctx);

            Q_EMIT getNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteApplicationDataTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        LazyMap(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteApplicationDataTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteApplicationDataRequestReady(
        LazyMap value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteApplicationDataRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getNoteApplicationDataRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteApplicationDataRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteApplicationDataEntryTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QString(
            Guid,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteApplicationDataEntryTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteApplicationDataEntryRequestReady(
        QString value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteApplicationDataEntryRequestReceived(
        Guid guid,
        QString key,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                key,
                ctx);

            Q_EMIT getNoteApplicationDataEntryRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteApplicationDataEntryRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreSetNoteApplicationDataEntryTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            QString,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreSetNoteApplicationDataEntryTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void setNoteApplicationDataEntryRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onSetNoteApplicationDataEntryRequestReceived(
        Guid guid,
        QString key,
        QString value,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                key,
                value,
                ctx);

            Q_EMIT setNoteApplicationDataEntryRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT setNoteApplicationDataEntryRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUnsetNoteApplicationDataEntryTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUnsetNoteApplicationDataEntryTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void unsetNoteApplicationDataEntryRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUnsetNoteApplicationDataEntryRequestReceived(
        Guid guid,
        QString key,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                key,
                ctx);

            Q_EMIT unsetNoteApplicationDataEntryRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT unsetNoteApplicationDataEntryRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteContentTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QString(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteContentTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteContentRequestReady(
        QString value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteContentRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getNoteContentRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteContentRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteSearchTextTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QString(
            Guid,
            bool,
            bool,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteSearchTextTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteSearchTextRequestReady(
        QString value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteSearchTextRequestReceived(
        Guid guid,
        bool noteOnly,
        bool tokenizeForIndexing,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                noteOnly,
                tokenizeForIndexing,
                ctx);

            Q_EMIT getNoteSearchTextRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteSearchTextRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceSearchTextTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QString(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceSearchTextTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceSearchTextRequestReady(
        QString value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceSearchTextRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getResourceSearchTextRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceSearchTextRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteTagNamesTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QStringList(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteTagNamesTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteTagNamesRequestReady(
        QStringList value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteTagNamesRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getNoteTagNamesRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteTagNamesRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreCreateNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Note(
            const Note &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreCreateNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void createNoteRequestReady(
        Note value,
        std::exception_ptr e);

public Q_SLOTS:
    void onCreateNoteRequestReceived(
        Note note,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                note,
                ctx);

            Q_EMIT createNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT createNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Note(
            const Note &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateNoteRequestReady(
        Note value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateNoteRequestReceived(
        Note note,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                note,
                ctx);

            Q_EMIT updateNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreDeleteNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreDeleteNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void deleteNoteRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onDeleteNoteRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT deleteNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT deleteNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreExpungeNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreExpungeNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void expungeNoteRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onExpungeNoteRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT expungeNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT expungeNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreCopyNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Note(
            Guid,
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreCopyNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void copyNoteRequestReady(
        Note value,
        std::exception_ptr e);

public Q_SLOTS:
    void onCopyNoteRequestReceived(
        Guid noteGuid,
        Guid toNotebookGuid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                noteGuid,
                toNotebookGuid,
                ctx);

            Q_EMIT copyNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT copyNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListNoteVersionsTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<NoteVersionId>(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListNoteVersionsTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listNoteVersionsRequestReady(
        QList<NoteVersionId> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListNoteVersionsRequestReceived(
        Guid noteGuid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                noteGuid,
                ctx);

            Q_EMIT listNoteVersionsRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listNoteVersionsRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNoteVersionTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Note(
            Guid,
            qint32,
            bool,
            bool,
            bool,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNoteVersionTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNoteVersionRequestReady(
        Note value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNoteVersionRequestReceived(
        Guid noteGuid,
        qint32 updateSequenceNum,
        bool withResourcesData,
        bool withResourcesRecognition,
        bool withResourcesAlternateData,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                noteGuid,
                updateSequenceNum,
                withResourcesData,
                withResourcesRecognition,
                withResourcesAlternateData,
                ctx);

            Q_EMIT getNoteVersionRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNoteVersionRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Resource(
            Guid,
            bool,
            bool,
            bool,
            bool,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceRequestReady(
        Resource value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceRequestReceived(
        Guid guid,
        bool withData,
        bool withRecognition,
        bool withAttributes,
        bool withAlternateData,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                withData,
                withRecognition,
                withAttributes,
                withAlternateData,
                ctx);

            Q_EMIT getResourceRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceApplicationDataTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        LazyMap(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceApplicationDataTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceApplicationDataRequestReady(
        LazyMap value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceApplicationDataRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getResourceApplicationDataRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceApplicationDataRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceApplicationDataEntryTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QString(
            Guid,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceApplicationDataEntryTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceApplicationDataEntryRequestReady(
        QString value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceApplicationDataEntryRequestReceived(
        Guid guid,
        QString key,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                key,
                ctx);

            Q_EMIT getResourceApplicationDataEntryRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceApplicationDataEntryRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreSetResourceApplicationDataEntryTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            QString,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreSetResourceApplicationDataEntryTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void setResourceApplicationDataEntryRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onSetResourceApplicationDataEntryRequestReceived(
        Guid guid,
        QString key,
        QString value,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                key,
                value,
                ctx);

            Q_EMIT setResourceApplicationDataEntryRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT setResourceApplicationDataEntryRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUnsetResourceApplicationDataEntryTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUnsetResourceApplicationDataEntryTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void unsetResourceApplicationDataEntryRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUnsetResourceApplicationDataEntryRequestReceived(
        Guid guid,
        QString key,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                key,
                ctx);

            Q_EMIT unsetResourceApplicationDataEntryRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT unsetResourceApplicationDataEntryRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateResourceTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            const Resource &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateResourceTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateResourceRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateResourceRequestReceived(
        Resource resource,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                resource,
                ctx);

            Q_EMIT updateResourceRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateResourceRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceDataTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QByteArray(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceDataTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceDataRequestReady(
        QByteArray value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceDataRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getResourceDataRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceDataRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceByHashTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Resource(
            Guid,
            QByteArray,
            bool,
            bool,
            bool,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceByHashTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceByHashRequestReady(
        Resource value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceByHashRequestReceived(
        Guid noteGuid,
        QByteArray contentHash,
        bool withData,
        bool withRecognition,
        bool withAlternateData,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                noteGuid,
                contentHash,
                withData,
                withRecognition,
                withAlternateData,
                ctx);

            Q_EMIT getResourceByHashRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceByHashRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceRecognitionTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QByteArray(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceRecognitionTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceRecognitionRequestReady(
        QByteArray value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceRecognitionRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getResourceRecognitionRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceRecognitionRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceAlternateDataTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QByteArray(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceAlternateDataTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceAlternateDataRequestReady(
        QByteArray value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceAlternateDataRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getResourceAlternateDataRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceAlternateDataRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetResourceAttributesTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        ResourceAttributes(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetResourceAttributesTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getResourceAttributesRequestReady(
        ResourceAttributes value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetResourceAttributesRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT getResourceAttributesRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getResourceAttributesRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetPublicNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Notebook(
            UserID,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetPublicNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getPublicNotebookRequestReady(
        Notebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetPublicNotebookRequestReceived(
        UserID userId,
        QString publicUri,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                userId,
                publicUri,
                ctx);

            Q_EMIT getPublicNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getPublicNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreShareNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SharedNotebook(
            const SharedNotebook &,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreShareNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void shareNotebookRequestReady(
        SharedNotebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onShareNotebookRequestReceived(
        SharedNotebook sharedNotebook,
        QString message,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                sharedNotebook,
                message,
                ctx);

            Q_EMIT shareNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT shareNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreCreateOrUpdateNotebookSharesTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        CreateOrUpdateNotebookSharesResult(
            const NotebookShareTemplate &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreCreateOrUpdateNotebookSharesTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void createOrUpdateNotebookSharesRequestReady(
        CreateOrUpdateNotebookSharesResult value,
        std::exception_ptr e);

public Q_SLOTS:
    void onCreateOrUpdateNotebookSharesRequestReceived(
        NotebookShareTemplate shareTemplate,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                shareTemplate,
                ctx);

            Q_EMIT createOrUpdateNotebookSharesRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT createOrUpdateNotebookSharesRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateSharedNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            const SharedNotebook &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateSharedNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateSharedNotebookRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateSharedNotebookRequestReceived(
        SharedNotebook sharedNotebook,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                sharedNotebook,
                ctx);

            Q_EMIT updateSharedNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateSharedNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreSetNotebookRecipientSettingsTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        Notebook(
            QString,
            const NotebookRecipientSettings &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreSetNotebookRecipientSettingsTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void setNotebookRecipientSettingsRequestReady(
        Notebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onSetNotebookRecipientSettingsRequestReceived(
        QString notebookGuid,
        NotebookRecipientSettings recipientSettings,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                notebookGuid,
                recipientSettings,
                ctx);

            Q_EMIT setNotebookRecipientSettingsRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT setNotebookRecipientSettingsRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListSharedNotebooksTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<SharedNotebook>(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListSharedNotebooksTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listSharedNotebooksRequestReady(
        QList<SharedNotebook> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListSharedNotebooksRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT listSharedNotebooksRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listSharedNotebooksRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreCreateLinkedNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        LinkedNotebook(
            const LinkedNotebook &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreCreateLinkedNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void createLinkedNotebookRequestReady(
        LinkedNotebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onCreateLinkedNotebookRequestReceived(
        LinkedNotebook linkedNotebook,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                linkedNotebook,
                ctx);

            Q_EMIT createLinkedNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT createLinkedNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateLinkedNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            const LinkedNotebook &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateLinkedNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateLinkedNotebookRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateLinkedNotebookRequestReceived(
        LinkedNotebook linkedNotebook,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                linkedNotebook,
                ctx);

            Q_EMIT updateLinkedNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateLinkedNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreListLinkedNotebooksTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QList<LinkedNotebook>(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreListLinkedNotebooksTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void listLinkedNotebooksRequestReady(
        QList<LinkedNotebook> value,
        std::exception_ptr e);

public Q_SLOTS:
    void onListLinkedNotebooksRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT listLinkedNotebooksRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT listLinkedNotebooksRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreExpungeLinkedNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        qint32(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreExpungeLinkedNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void expungeLinkedNotebookRequestReady(
        qint32 value,
        std::exception_ptr e);

public Q_SLOTS:
    void onExpungeLinkedNotebookRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT expungeLinkedNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT expungeLinkedNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreAuthenticateToSharedNotebookTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        AuthenticationResult(
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreAuthenticateToSharedNotebookTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void authenticateToSharedNotebookRequestReady(
        AuthenticationResult value,
        std::exception_ptr e);

public Q_SLOTS:
    void onAuthenticateToSharedNotebookRequestReceived(
        QString shareKeyOrGlobalId,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                shareKeyOrGlobalId,
                ctx);

            Q_EMIT authenticateToSharedNotebookRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT authenticateToSharedNotebookRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetSharedNotebookByAuthTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        SharedNotebook(
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetSharedNotebookByAuthTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getSharedNotebookByAuthRequestReady(
        SharedNotebook value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetSharedNotebookByAuthRequestReceived(
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                ctx);

            Q_EMIT getSharedNotebookByAuthRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getSharedNotebookByAuthRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreEmailNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        void(
            const NoteEmailParameters &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreEmailNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void emailNoteRequestReady(
        std::exception_ptr e);

public Q_SLOTS:
    void onEmailNoteRequestReceived(
        NoteEmailParameters parameters,
        IRequestContextPtr ctx)
    {
        try
        {
            m_executor(
                parameters,
                ctx);

            Q_EMIT emailNoteRequestReady(
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT emailNoteRequestReady(
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreShareNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        QString(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreShareNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void shareNoteRequestReady(
        QString value,
        std::exception_ptr e);

public Q_SLOTS:
    void onShareNoteRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                ctx);

            Q_EMIT shareNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT shareNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreStopSharingNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        void(
            Guid,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreStopSharingNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void stopSharingNoteRequestReady(
        std::exception_ptr e);

public Q_SLOTS:
    void onStopSharingNoteRequestReceived(
        Guid guid,
        IRequestContextPtr ctx)
    {
        try
        {
            m_executor(
                guid,
                ctx);

            Q_EMIT stopSharingNoteRequestReady(
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT stopSharingNoteRequestReady(
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreAuthenticateToSharedNoteTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        AuthenticationResult(
            QString,
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreAuthenticateToSharedNoteTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void authenticateToSharedNoteRequestReady(
        AuthenticationResult value,
        std::exception_ptr e);

public Q_SLOTS:
    void onAuthenticateToSharedNoteRequestReceived(
        QString guid,
        QString noteKey,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                guid,
                noteKey,
                ctx);

            Q_EMIT authenticateToSharedNoteRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT authenticateToSharedNoteRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreFindRelatedTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        RelatedResult(
            const RelatedQuery &,
            const RelatedResultSpec &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreFindRelatedTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void findRelatedRequestReady(
        RelatedResult value,
        std::exception_ptr e);

public Q_SLOTS:
    void onFindRelatedRequestReceived(
        RelatedQuery query,
        RelatedResultSpec resultSpec,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                query,
                resultSpec,
                ctx);

            Q_EMIT findRelatedRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT findRelatedRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreUpdateNoteIfUsnMatchesTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        UpdateNoteIfUsnMatchesResult(
            const Note &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreUpdateNoteIfUsnMatchesTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void updateNoteIfUsnMatchesRequestReady(
        UpdateNoteIfUsnMatchesResult value,
        std::exception_ptr e);

public Q_SLOTS:
    void onUpdateNoteIfUsnMatchesRequestReceived(
        Note note,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                note,
                ctx);

            Q_EMIT updateNoteIfUsnMatchesRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT updateNoteIfUsnMatchesRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreManageNotebookSharesTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        ManageNotebookSharesResult(
            const ManageNotebookSharesParameters &,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreManageNotebookSharesTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void manageNotebookSharesRequestReady(
        ManageNotebookSharesResult value,
        std::exception_ptr e);

public Q_SLOTS:
    void onManageNotebookSharesRequestReceived(
        ManageNotebookSharesParameters parameters,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                parameters,
                ctx);

            Q_EMIT manageNotebookSharesRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT manageNotebookSharesRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

class NoteStoreGetNotebookSharesTesterHelper: public QObject
{
    Q_OBJECT
public:
    using Executor = std::function<
        ShareRelationships(
            QString,
            IRequestContextPtr ctx)>;

public:
    explicit NoteStoreGetNotebookSharesTesterHelper(
            Executor executor,
            QObject * parent = nullptr) :
        QObject(parent),
        m_executor(std::move(executor))
    {}

Q_SIGNALS:
    void getNotebookSharesRequestReady(
        ShareRelationships value,
        std::exception_ptr e);

public Q_SLOTS:
    void onGetNotebookSharesRequestReceived(
        QString notebookGuid,
        IRequestContextPtr ctx)
    {
        try
        {
            auto v = m_executor(
                notebookGuid,
                ctx);

            Q_EMIT getNotebookSharesRequestReady(
                v,
                std::exception_ptr{});
        }
        catch(const std::exception &)
        {
            Q_EMIT getNotebookSharesRequestReady(
                {},
                std::current_exception());
        }
    }

private:
    Executor m_executor;
};

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetSyncState()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncState response = generateRandomSyncState();

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SyncState res = noteStore->getSyncState(
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetSyncState()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_MANY);
    userException.setParameter(generateRandomString());

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncState res = noteStore->getSyncState(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetSyncState()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncState res = noteStore->getSyncState(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetSyncState()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncState res = noteStore->getSyncState(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetSyncStateAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncState response = generateRandomSyncState();

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getSyncStateAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<SyncState>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetSyncStateAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSyncStateAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetSyncStateAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSyncStateAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetSyncStateAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetSyncStateTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequest,
        &helper,
        &NoteStoreGetSyncStateTesterHelper::onGetSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSyncStateTesterHelper::getSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSyncStateAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetFilteredSyncChunk()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncChunk response = generateRandomSyncChunk();

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SyncChunk res = noteStore->getFilteredSyncChunk(
        afterUSN,
        maxEntries,
        filter,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetFilteredSyncChunk()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    userException.setParameter(generateRandomString());

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncChunk res = noteStore->getFilteredSyncChunk(
            afterUSN,
            maxEntries,
            filter,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetFilteredSyncChunk()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncChunk res = noteStore->getFilteredSyncChunk(
            afterUSN,
            maxEntries,
            filter,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetFilteredSyncChunk()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncChunk res = noteStore->getFilteredSyncChunk(
            afterUSN,
            maxEntries,
            filter,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetFilteredSyncChunkAsync()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncChunk response = generateRandomSyncChunk();

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getFilteredSyncChunkAsync(
        afterUSN,
        maxEntries,
        filter,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<SyncChunk>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetFilteredSyncChunkAsync()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    userException.setParameter(generateRandomString());

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getFilteredSyncChunkAsync(
            afterUSN,
            maxEntries,
            filter,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetFilteredSyncChunkAsync()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getFilteredSyncChunkAsync(
            afterUSN,
            maxEntries,
            filter,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetFilteredSyncChunkAsync()
{
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    SyncChunkFilter filter = generateRandomSyncChunkFilter();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetFilteredSyncChunkTesterHelper helper(
        [&] (qint32 afterUSNParam,
             qint32 maxEntriesParam,
             const SyncChunkFilter & filterParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(filter == filterParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequest,
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::onGetFilteredSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetFilteredSyncChunkTesterHelper::getFilteredSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetFilteredSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getFilteredSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getFilteredSyncChunkAsync(
            afterUSN,
            maxEntries,
            filter,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetLinkedNotebookSyncState()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncState response = generateRandomSyncState();

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SyncState res = noteStore->getLinkedNotebookSyncState(
        linkedNotebook,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetLinkedNotebookSyncState()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    userException.setParameter(generateRandomString());

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncState res = noteStore->getLinkedNotebookSyncState(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetLinkedNotebookSyncState()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BUSINESS_SECURITY_LOGIN_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncState res = noteStore->getLinkedNotebookSyncState(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetLinkedNotebookSyncState()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncState res = noteStore->getLinkedNotebookSyncState(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetLinkedNotebookSyncState()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncState res = noteStore->getLinkedNotebookSyncState(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetLinkedNotebookSyncStateAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncState response = generateRandomSyncState();

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getLinkedNotebookSyncStateAsync(
        linkedNotebook,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<SyncState>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetLinkedNotebookSyncStateAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncStateAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetLinkedNotebookSyncStateAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncStateAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetLinkedNotebookSyncStateAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncStateAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetLinkedNotebookSyncStateAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetLinkedNotebookSyncStateTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> SyncState
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::onGetLinkedNotebookSyncStateRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncStateTesterHelper::getLinkedNotebookSyncStateRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncStateRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncStateRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncStateAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetLinkedNotebookSyncChunk()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncChunk response = generateRandomSyncChunk();

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SyncChunk res = noteStore->getLinkedNotebookSyncChunk(
        linkedNotebook,
        afterUSN,
        maxEntries,
        fullSyncOnly,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetLinkedNotebookSyncChunk()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncChunk res = noteStore->getLinkedNotebookSyncChunk(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetLinkedNotebookSyncChunk()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncChunk res = noteStore->getLinkedNotebookSyncChunk(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetLinkedNotebookSyncChunk()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncChunk res = noteStore->getLinkedNotebookSyncChunk(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetLinkedNotebookSyncChunk()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SyncChunk res = noteStore->getLinkedNotebookSyncChunk(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetLinkedNotebookSyncChunkAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SyncChunk response = generateRandomSyncChunk();

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getLinkedNotebookSyncChunkAsync(
        linkedNotebook,
        afterUSN,
        maxEntries,
        fullSyncOnly,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<SyncChunk>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetLinkedNotebookSyncChunkAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    userException.setParameter(generateRandomString());

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncChunkAsync(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetLinkedNotebookSyncChunkAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncChunkAsync(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetLinkedNotebookSyncChunkAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncChunkAsync(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetLinkedNotebookSyncChunkAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    qint32 afterUSN = generateRandomInt32();
    qint32 maxEntries = generateRandomInt32();
    bool fullSyncOnly = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetLinkedNotebookSyncChunkTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             qint32 afterUSNParam,
             qint32 maxEntriesParam,
             bool fullSyncOnlyParam,
             IRequestContextPtr ctxParam) -> SyncChunk
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            Q_ASSERT(afterUSN == afterUSNParam);
            Q_ASSERT(maxEntries == maxEntriesParam);
            Q_ASSERT(fullSyncOnly == fullSyncOnlyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequest,
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::onGetLinkedNotebookSyncChunkRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetLinkedNotebookSyncChunkTesterHelper::getLinkedNotebookSyncChunkRequestReady,
        &server,
        &NoteStoreServer::onGetLinkedNotebookSyncChunkRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getLinkedNotebookSyncChunkRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getLinkedNotebookSyncChunkAsync(
            linkedNotebook,
            afterUSN,
            maxEntries,
            fullSyncOnly,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Notebook> response;
    response << generateRandomNotebook();
    response << generateRandomNotebook();
    response << generateRandomNotebook();

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<Notebook> res = noteStore->listNotebooks(
        ctx);

    compareListValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Notebook> res = noteStore->listNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Notebook> res = noteStore->listNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Notebook> res = noteStore->listNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Notebook> response;
    response << generateRandomNotebook();
    response << generateRandomNotebook();
    response << generateRandomNotebook();

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listNotebooksAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareListValuesWithoutLocalIds(qvariant_cast<QList<Notebook>>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_MANY);
    userException.setParameter(generateRandomString());

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequest,
        &helper,
        &NoteStoreListNotebooksTesterHelper::onListNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNotebooksTesterHelper::listNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListAccessibleBusinessNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Notebook> response;
    response << generateRandomNotebook();
    response << generateRandomNotebook();
    response << generateRandomNotebook();

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<Notebook> res = noteStore->listAccessibleBusinessNotebooks(
        ctx);

    compareListValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListAccessibleBusinessNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Notebook> res = noteStore->listAccessibleBusinessNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListAccessibleBusinessNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Notebook> res = noteStore->listAccessibleBusinessNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListAccessibleBusinessNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Notebook> res = noteStore->listAccessibleBusinessNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListAccessibleBusinessNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Notebook> response;
    response << generateRandomNotebook();
    response << generateRandomNotebook();
    response << generateRandomNotebook();

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listAccessibleBusinessNotebooksAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareListValuesWithoutLocalIds(qvariant_cast<QList<Notebook>>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListAccessibleBusinessNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listAccessibleBusinessNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListAccessibleBusinessNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listAccessibleBusinessNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListAccessibleBusinessNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListAccessibleBusinessNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Notebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequest,
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::onListAccessibleBusinessNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListAccessibleBusinessNotebooksTesterHelper::listAccessibleBusinessNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListAccessibleBusinessNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listAccessibleBusinessNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listAccessibleBusinessNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Notebook res = noteStore->getNotebook(
        guid,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    userException.setParameter(generateRandomString());

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TAKEN_DOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNotebookAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Notebook>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    userException.setParameter(generateRandomString());

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequest,
        &helper,
        &NoteStoreGetNotebookTesterHelper::onGetNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookTesterHelper::getNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetDefaultNotebook()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Notebook res = noteStore->getDefaultNotebook(
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetDefaultNotebook()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::BUSINESS_SECURITY_LOGIN_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getDefaultNotebook(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetDefaultNotebook()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::RATE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getDefaultNotebook(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetDefaultNotebook()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getDefaultNotebook(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetDefaultNotebookAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getDefaultNotebookAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Notebook>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetDefaultNotebookAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getDefaultNotebookAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetDefaultNotebookAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getDefaultNotebookAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetDefaultNotebookAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetDefaultNotebookTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequest,
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::onGetDefaultNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetDefaultNotebookTesterHelper::getDefaultNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetDefaultNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getDefaultNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getDefaultNotebookAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteCreateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Notebook res = noteStore->createNotebook(
        notebook,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    userException.setParameter(generateRandomString());

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->createNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->createNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->createNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->createNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteCreateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->createNotebookAsync(
        notebook,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Notebook>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_MANY);
    userException.setParameter(generateRandomString());

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequest,
        &helper,
        &NoteStoreCreateNotebookTesterHelper::onCreateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNotebookTesterHelper::createNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->updateNotebook(
        notebook,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateNotebook()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateNotebook(
            notebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateNotebookAsync(
        notebook,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TAKEN_DOWN);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateNotebookAsync()
{
    Notebook notebook = generateRandomNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateNotebookTesterHelper helper(
        [&] (const Notebook & notebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(notebookParam, notebook);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequest,
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::onUpdateNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNotebookTesterHelper::updateNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNotebookAsync(
            notebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteExpungeNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->expungeNotebook(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteExpungeNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->expungeNotebookAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequest,
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::onExpungeNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNotebookTesterHelper::expungeNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListTags()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Tag> response;
    response << generateRandomTag();
    response << generateRandomTag();
    response << generateRandomTag();

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<Tag> res = noteStore->listTags(
        ctx);

    compareListValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListTags()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Tag> res = noteStore->listTags(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListTags()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TOO_MANY);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Tag> res = noteStore->listTags(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListTags()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Tag> res = noteStore->listTags(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListTagsAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Tag> response;
    response << generateRandomTag();
    response << generateRandomTag();
    response << generateRandomTag();

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listTagsAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareListValuesWithoutLocalIds(qvariant_cast<QList<Tag>>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListTagsAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    userException.setParameter(generateRandomString());

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listTagsAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListTagsAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listTagsAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListTagsAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListTagsTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequest,
        &helper,
        &NoteStoreListTagsTesterHelper::onListTagsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsTesterHelper::listTagsRequestReady,
        &server,
        &NoteStoreServer::onListTagsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listTagsAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListTagsByNotebook()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Tag> response;
    response << generateRandomTag();
    response << generateRandomTag();
    response << generateRandomTag();

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<Tag> res = noteStore->listTagsByNotebook(
        notebookGuid,
        ctx);

    compareListValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListTagsByNotebook()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    userException.setParameter(generateRandomString());

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Tag> res = noteStore->listTagsByNotebook(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListTagsByNotebook()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Tag> res = noteStore->listTagsByNotebook(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListTagsByNotebook()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Tag> res = noteStore->listTagsByNotebook(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListTagsByNotebook()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<Tag> res = noteStore->listTagsByNotebook(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListTagsByNotebookAsync()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<Tag> response;
    response << generateRandomTag();
    response << generateRandomTag();
    response << generateRandomTag();

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listTagsByNotebookAsync(
        notebookGuid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareListValuesWithoutLocalIds(qvariant_cast<QList<Tag>>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListTagsByNotebookAsync()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listTagsByNotebookAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListTagsByNotebookAsync()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TOO_FEW);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listTagsByNotebookAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListTagsByNotebookAsync()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listTagsByNotebookAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListTagsByNotebookAsync()
{
    Guid notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListTagsByNotebookTesterHelper helper(
        [&] (const Guid & notebookGuidParam,
             IRequestContextPtr ctxParam) -> QList<Tag>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequest,
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::onListTagsByNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListTagsByNotebookTesterHelper::listTagsByNotebookRequestReady,
        &server,
        &NoteStoreServer::onListTagsByNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listTagsByNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listTagsByNotebookAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Tag response = generateRandomTag();

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Tag res = noteStore->getTag(
        guid,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    userException.setParameter(generateRandomString());

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->getTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->getTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->getTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->getTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Tag response = generateRandomTag();

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getTagAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Tag>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequest,
        &helper,
        &NoteStoreGetTagTesterHelper::onGetTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetTagTesterHelper::getTagRequestReady,
        &server,
        &NoteStoreServer::onGetTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteCreateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Tag response = generateRandomTag();

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Tag res = noteStore->createTag(
        tag,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->createTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->createTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->createTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Tag res = noteStore->createTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteCreateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Tag response = generateRandomTag();

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->createTagAsync(
        tag,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Tag>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> Tag
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequest,
        &helper,
        &NoteStoreCreateTagTesterHelper::onCreateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateTagTesterHelper::createTagRequestReady,
        &server,
        &NoteStoreServer::onCreateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->updateTag(
        tag,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TAKEN_DOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateTag()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateTag(
            tag,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateTagAsync(
        tag,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNKNOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateTagAsync()
{
    Tag tag = generateRandomTag();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateTagTesterHelper helper(
        [&] (const Tag & tagParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(tagParam, tag);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequest,
        &helper,
        &NoteStoreUpdateTagTesterHelper::onUpdateTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateTagTesterHelper::updateTagRequestReady,
        &server,
        &NoteStoreServer::onUpdateTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateTagAsync(
            tag,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUntagAll()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    noteStore->untagAll(
        guid,
        ctx);

}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUntagAll()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_FEW);
    userException.setParameter(generateRandomString());

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->untagAll(
            guid,
            ctx);

    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUntagAll()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->untagAll(
            guid,
            ctx);

    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUntagAll()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->untagAll(
            guid,
            ctx);

    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUntagAll()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->untagAll(
            guid,
            ctx);

    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUntagAllAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->untagAllAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUntagAllAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    userException.setParameter(generateRandomString());

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->untagAllAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUntagAllAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->untagAllAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUntagAllAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->untagAllAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUntagAllAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUntagAllTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequest,
        &helper,
        &NoteStoreUntagAllTesterHelper::onUntagAllRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUntagAllTesterHelper::untagAllRequestReady,
        &server,
        &NoteStoreServer::onUntagAllRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::untagAllRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->untagAllAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteExpungeTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->expungeTag(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeTag()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeTag(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteExpungeTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->expungeTagAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeTagAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeTagTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequest,
        &helper,
        &NoteStoreExpungeTagTesterHelper::onExpungeTagRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeTagTesterHelper::expungeTagRequestReady,
        &server,
        &NoteStoreServer::onExpungeTagRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeTagRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeTagAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListSearches()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<SavedSearch> response;
    response << generateRandomSavedSearch();
    response << generateRandomSavedSearch();
    response << generateRandomSavedSearch();

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<SavedSearch> res = noteStore->listSearches(
        ctx);

    compareListValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListSearches()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<SavedSearch> res = noteStore->listSearches(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListSearches()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<SavedSearch> res = noteStore->listSearches(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListSearches()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<SavedSearch> res = noteStore->listSearches(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListSearchesAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<SavedSearch> response;
    response << generateRandomSavedSearch();
    response << generateRandomSavedSearch();
    response << generateRandomSavedSearch();

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listSearchesAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareListValuesWithoutLocalIds(qvariant_cast<QList<SavedSearch>>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListSearchesAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    userException.setParameter(generateRandomString());

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listSearchesAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListSearchesAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listSearchesAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListSearchesAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListSearchesTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SavedSearch>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequest,
        &helper,
        &NoteStoreListSearchesTesterHelper::onListSearchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSearchesTesterHelper::listSearchesRequestReady,
        &server,
        &NoteStoreServer::onListSearchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSearchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listSearchesAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SavedSearch response = generateRandomSavedSearch();

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SavedSearch res = noteStore->getSearch(
        guid,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SavedSearch res = noteStore->getSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SavedSearch res = noteStore->getSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SavedSearch res = noteStore->getSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SavedSearch res = noteStore->getSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SavedSearch response = generateRandomSavedSearch();

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getSearchAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<SavedSearch>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    userException.setParameter(generateRandomString());

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequest,
        &helper,
        &NoteStoreGetSearchTesterHelper::onGetSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSearchTesterHelper::getSearchRequestReady,
        &server,
        &NoteStoreServer::onGetSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteCreateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SavedSearch response = generateRandomSavedSearch();

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SavedSearch res = noteStore->createSearch(
        search,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    userException.setParameter(generateRandomString());

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SavedSearch res = noteStore->createSearch(
            search,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BUSINESS_SECURITY_LOGIN_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SavedSearch res = noteStore->createSearch(
            search,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SavedSearch res = noteStore->createSearch(
            search,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteCreateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SavedSearch response = generateRandomSavedSearch();

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->createSearchAsync(
        search,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<SavedSearch>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    userException.setParameter(generateRandomString());

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createSearchAsync(
            search,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createSearchAsync(
            search,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> SavedSearch
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequest,
        &helper,
        &NoteStoreCreateSearchTesterHelper::onCreateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateSearchTesterHelper::createSearchRequestReady,
        &server,
        &NoteStoreServer::onCreateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createSearchAsync(
            search,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->updateSearch(
        search,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSearch(
            search,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSearch(
            search,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSearch(
            search,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateSearch()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSearch(
            search,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateSearchAsync(
        search,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSearchAsync(
            search,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSearchAsync(
            search,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSearchAsync(
            search,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateSearchAsync()
{
    SavedSearch search = generateRandomSavedSearch();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateSearchTesterHelper helper(
        [&] (const SavedSearch & searchParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(searchParam, search);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequest,
        &helper,
        &NoteStoreUpdateSearchTesterHelper::onUpdateSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSearchTesterHelper::updateSearchRequestReady,
        &server,
        &NoteStoreServer::onUpdateSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSearchAsync(
            search,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteExpungeSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->expungeSearch(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeSearch()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeSearch(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteExpungeSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->expungeSearchAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::RATE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeSearchAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeSearchTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequest,
        &helper,
        &NoteStoreExpungeSearchTesterHelper::onExpungeSearchRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeSearchTesterHelper::expungeSearchRequestReady,
        &server,
        &NoteStoreServer::onExpungeSearchRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeSearchRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeSearchAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteFindNoteOffset()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->findNoteOffset(
        filter,
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindNoteOffset()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNKNOWN);
    userException.setParameter(generateRandomString());

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->findNoteOffset(
            filter,
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindNoteOffset()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->findNoteOffset(
            filter,
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindNoteOffset()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->findNoteOffset(
            filter,
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindNoteOffset()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->findNoteOffset(
            filter,
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteFindNoteOffsetAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->findNoteOffsetAsync(
        filter,
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindNoteOffsetAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    userException.setParameter(generateRandomString());

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteOffsetAsync(
            filter,
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindNoteOffsetAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TOO_FEW);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteOffsetAsync(
            filter,
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindNoteOffsetAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteOffsetAsync(
            filter,
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindNoteOffsetAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindNoteOffsetTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequest,
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::onFindNoteOffsetRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteOffsetTesterHelper::findNoteOffsetRequestReady,
        &server,
        &NoteStoreServer::onFindNoteOffsetRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteOffsetRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteOffsetAsync(
            filter,
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteFindNotesMetadata()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NotesMetadataList response = generateRandomNotesMetadataList();

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    NotesMetadataList res = noteStore->findNotesMetadata(
        filter,
        offset,
        maxNotes,
        resultSpec,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindNotesMetadata()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NotesMetadataList res = noteStore->findNotesMetadata(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindNotesMetadata()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NotesMetadataList res = noteStore->findNotesMetadata(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindNotesMetadata()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NotesMetadataList res = noteStore->findNotesMetadata(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindNotesMetadata()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NotesMetadataList res = noteStore->findNotesMetadata(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteFindNotesMetadataAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NotesMetadataList response = generateRandomNotesMetadataList();

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->findNotesMetadataAsync(
        filter,
        offset,
        maxNotes,
        resultSpec,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<NotesMetadataList>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindNotesMetadataAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    userException.setParameter(generateRandomString());

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNotesMetadataAsync(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindNotesMetadataAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::RATE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNotesMetadataAsync(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindNotesMetadataAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNotesMetadataAsync(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindNotesMetadataAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    qint32 offset = generateRandomInt32();
    qint32 maxNotes = generateRandomInt32();
    NotesMetadataResultSpec resultSpec = generateRandomNotesMetadataResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindNotesMetadataTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             qint32 offsetParam,
             qint32 maxNotesParam,
             const NotesMetadataResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> NotesMetadataList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(offset == offsetParam);
            Q_ASSERT(maxNotes == maxNotesParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequest,
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::onFindNotesMetadataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNotesMetadataTesterHelper::findNotesMetadataRequestReady,
        &server,
        &NoteStoreServer::onFindNotesMetadataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNotesMetadataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNotesMetadataAsync(
            filter,
            offset,
            maxNotes,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteFindNoteCounts()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteCollectionCounts response = generateRandomNoteCollectionCounts();

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    NoteCollectionCounts res = noteStore->findNoteCounts(
        filter,
        withTrash,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindNoteCounts()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NoteCollectionCounts res = noteStore->findNoteCounts(
            filter,
            withTrash,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindNoteCounts()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NoteCollectionCounts res = noteStore->findNoteCounts(
            filter,
            withTrash,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindNoteCounts()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NoteCollectionCounts res = noteStore->findNoteCounts(
            filter,
            withTrash,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindNoteCounts()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        NoteCollectionCounts res = noteStore->findNoteCounts(
            filter,
            withTrash,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteFindNoteCountsAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteCollectionCounts response = generateRandomNoteCollectionCounts();

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->findNoteCountsAsync(
        filter,
        withTrash,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<NoteCollectionCounts>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindNoteCountsAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteCountsAsync(
            filter,
            withTrash,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindNoteCountsAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteCountsAsync(
            filter,
            withTrash,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindNoteCountsAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteCountsAsync(
            filter,
            withTrash,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindNoteCountsAsync()
{
    NoteFilter filter = generateRandomNoteFilter();
    bool withTrash = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindNoteCountsTesterHelper helper(
        [&] (const NoteFilter & filterParam,
             bool withTrashParam,
             IRequestContextPtr ctxParam) -> NoteCollectionCounts
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(filter == filterParam);
            Q_ASSERT(withTrash == withTrashParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequest,
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::onFindNoteCountsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindNoteCountsTesterHelper::findNoteCountsRequestReady,
        &server,
        &NoteStoreServer::onFindNoteCountsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findNoteCountsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findNoteCountsAsync(
            filter,
            withTrash,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNoteWithResultSpec()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Note res = noteStore->getNoteWithResultSpec(
        guid,
        resultSpec,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteWithResultSpec()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteWithResultSpec(
            guid,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteWithResultSpec()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteWithResultSpec(
            guid,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteWithResultSpec()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteWithResultSpec(
            guid,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteWithResultSpec()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteWithResultSpec(
            guid,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteWithResultSpecAsync()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteWithResultSpecAsync(
        guid,
        resultSpec,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Note>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteWithResultSpecAsync()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_MANY);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteWithResultSpecAsync(
            guid,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteWithResultSpecAsync()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteWithResultSpecAsync(
            guid,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteWithResultSpecAsync()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteWithResultSpecAsync(
            guid,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteWithResultSpecAsync()
{
    Guid guid = generateRandomString();
    NoteResultSpec resultSpec = generateRandomNoteResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteWithResultSpecTesterHelper helper(
        [&] (const Guid & guidParam,
             const NoteResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequest,
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::onGetNoteWithResultSpecRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteWithResultSpecTesterHelper::getNoteWithResultSpecRequestReady,
        &server,
        &NoteStoreServer::onGetNoteWithResultSpecRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteWithResultSpecRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteWithResultSpecAsync(
            guid,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNote()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Note res = noteStore->getNote(
        guid,
        withContent,
        withResourcesData,
        withResourcesRecognition,
        withResourcesAlternateData,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNote()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNote(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNote()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNote(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNote()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNote(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNote()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNote(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteAsync()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteAsync(
        guid,
        withContent,
        withResourcesData,
        withResourcesRecognition,
        withResourcesAlternateData,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Note>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteAsync()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteAsync(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteAsync()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteAsync(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteAsync()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteAsync(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteAsync()
{
    Guid guid = generateRandomString();
    bool withContent = generateRandomBool();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withContentParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withContent == withContentParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequest,
        &helper,
        &NoteStoreGetNoteTesterHelper::onGetNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTesterHelper::getNoteRequestReady,
        &server,
        &NoteStoreServer::onGetNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteAsync(
            guid,
            withContent,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNoteApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    LazyMap response = generateRandomLazyMap();

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    LazyMap res = noteStore->getNoteApplicationData(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getNoteApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getNoteApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getNoteApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getNoteApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    LazyMap response = generateRandomLazyMap();

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteApplicationDataAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<LazyMap>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_MANY);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::onGetNoteApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataTesterHelper::getNoteApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QString res = noteStore->getNoteApplicationDataEntry(
        guid,
        key,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_MANY);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteApplicationDataEntryAsync(
        guid,
        key,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QString>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::onGetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteApplicationDataEntryTesterHelper::getNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteSetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->setNoteApplicationDataEntry(
        guid,
        key,
        value,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInSetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNKNOWN);
    userException.setParameter(generateRandomString());

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setNoteApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInSetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setNoteApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInSetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setNoteApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInSetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setNoteApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteSetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->setNoteApplicationDataEntryAsync(
        guid,
        key,
        value,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInSetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    userException.setParameter(generateRandomString());

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNoteApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInSetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNKNOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNoteApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInSetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNoteApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInSetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreSetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::onSetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNoteApplicationDataEntryTesterHelper::setNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNoteApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUnsetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->unsetNoteApplicationDataEntry(
        guid,
        key,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUnsetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    userException.setParameter(generateRandomString());

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUnsetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TAKEN_DOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUnsetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUnsetNoteApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetNoteApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUnsetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->unsetNoteApplicationDataEntryAsync(
        guid,
        key,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUnsetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    userException.setParameter(generateRandomString());

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUnsetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUnsetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUnsetNoteApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUnsetNoteApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::onUnsetNoteApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetNoteApplicationDataEntryTesterHelper::unsetNoteApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetNoteApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetNoteApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetNoteApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNoteContent()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QString res = noteStore->getNoteContent(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteContent()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteContent(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteContent()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteContent(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteContent()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteContent(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteContent()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteContent(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteContentAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteContentAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QString>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteContentAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteContentAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteContentAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TOO_FEW);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteContentAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteContentAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteContentAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteContentAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteContentTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequest,
        &helper,
        &NoteStoreGetNoteContentTesterHelper::onGetNoteContentRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteContentTesterHelper::getNoteContentRequestReady,
        &server,
        &NoteStoreServer::onGetNoteContentRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteContentRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteContentAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNoteSearchText()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QString res = noteStore->getNoteSearchText(
        guid,
        noteOnly,
        tokenizeForIndexing,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteSearchText()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_MANY);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteSearchText(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteSearchText()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteSearchText(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteSearchText()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteSearchText(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteSearchText()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getNoteSearchText(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteSearchTextAsync()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteSearchTextAsync(
        guid,
        noteOnly,
        tokenizeForIndexing,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QString>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteSearchTextAsync()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteSearchTextAsync(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteSearchTextAsync()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteSearchTextAsync(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteSearchTextAsync()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteSearchTextAsync(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteSearchTextAsync()
{
    Guid guid = generateRandomString();
    bool noteOnly = generateRandomBool();
    bool tokenizeForIndexing = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             bool noteOnlyParam,
             bool tokenizeForIndexingParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteOnly == noteOnlyParam);
            Q_ASSERT(tokenizeForIndexing == tokenizeForIndexingParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequest,
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::onGetNoteSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteSearchTextTesterHelper::getNoteSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetNoteSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteSearchTextAsync(
            guid,
            noteOnly,
            tokenizeForIndexing,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceSearchText()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QString res = noteStore->getResourceSearchText(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceSearchText()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceSearchText(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceSearchText()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceSearchText(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceSearchText()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceSearchText(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceSearchText()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceSearchText(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceSearchTextAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceSearchTextAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QString>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceSearchTextAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceSearchTextAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceSearchTextAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceSearchTextAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceSearchTextAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceSearchTextAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceSearchTextAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceSearchTextTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequest,
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::onGetResourceSearchTextRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceSearchTextTesterHelper::getResourceSearchTextRequestReady,
        &server,
        &NoteStoreServer::onGetResourceSearchTextRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceSearchTextRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceSearchTextAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNoteTagNames()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QStringList response;
    response << generateRandomString();
    response << generateRandomString();
    response << generateRandomString();

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QStringList res = noteStore->getNoteTagNames(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteTagNames()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QStringList res = noteStore->getNoteTagNames(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteTagNames()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QStringList res = noteStore->getNoteTagNames(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteTagNames()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QStringList res = noteStore->getNoteTagNames(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteTagNames()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QStringList res = noteStore->getNoteTagNames(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteTagNamesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QStringList response;
    response << generateRandomString();
    response << generateRandomString();
    response << generateRandomString();

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteTagNamesAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QStringList>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteTagNamesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteTagNamesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteTagNamesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteTagNamesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteTagNamesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteTagNamesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteTagNamesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteTagNamesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QStringList
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequest,
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::onGetNoteTagNamesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteTagNamesTesterHelper::getNoteTagNamesRequestReady,
        &server,
        &NoteStoreServer::onGetNoteTagNamesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteTagNamesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteTagNamesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteCreateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Note res = noteStore->createNote(
        note,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->createNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->createNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->createNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->createNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteCreateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->createNoteAsync(
        note,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Note>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    userException.setParameter(generateRandomString());

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequest,
        &helper,
        &NoteStoreCreateNoteTesterHelper::onCreateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateNoteTesterHelper::createNoteRequestReady,
        &server,
        &NoteStoreServer::onCreateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Note res = noteStore->updateNote(
        note,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->updateNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->updateNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->updateNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateNote()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->updateNote(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateNoteAsync(
        note,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Note>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateNoteAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateNoteTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequest,
        &helper,
        &NoteStoreUpdateNoteTesterHelper::onUpdateNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteTesterHelper::updateNoteRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteDeleteNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->deleteNote(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInDeleteNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->deleteNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInDeleteNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BUSINESS_SECURITY_LOGIN_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->deleteNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInDeleteNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->deleteNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInDeleteNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->deleteNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteDeleteNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->deleteNoteAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInDeleteNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->deleteNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInDeleteNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->deleteNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInDeleteNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->deleteNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInDeleteNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreDeleteNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequest,
        &helper,
        &NoteStoreDeleteNoteTesterHelper::onDeleteNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreDeleteNoteTesterHelper::deleteNoteRequestReady,
        &server,
        &NoteStoreServer::onDeleteNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::deleteNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->deleteNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteExpungeNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->expungeNote(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteExpungeNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->expungeNoteAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequest,
        &helper,
        &NoteStoreExpungeNoteTesterHelper::onExpungeNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeNoteTesterHelper::expungeNoteRequestReady,
        &server,
        &NoteStoreServer::onExpungeNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteCopyNote()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Note res = noteStore->copyNote(
        noteGuid,
        toNotebookGuid,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCopyNote()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    userException.setParameter(generateRandomString());

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->copyNote(
            noteGuid,
            toNotebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCopyNote()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->copyNote(
            noteGuid,
            toNotebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCopyNote()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->copyNote(
            noteGuid,
            toNotebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCopyNote()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->copyNote(
            noteGuid,
            toNotebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteCopyNoteAsync()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->copyNoteAsync(
        noteGuid,
        toNotebookGuid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Note>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCopyNoteAsync()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    userException.setParameter(generateRandomString());

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->copyNoteAsync(
            noteGuid,
            toNotebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCopyNoteAsync()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->copyNoteAsync(
            noteGuid,
            toNotebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCopyNoteAsync()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->copyNoteAsync(
            noteGuid,
            toNotebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCopyNoteAsync()
{
    Guid noteGuid = generateRandomString();
    Guid toNotebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCopyNoteTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             const Guid & toNotebookGuidParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(toNotebookGuid == toNotebookGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequest,
        &helper,
        &NoteStoreCopyNoteTesterHelper::onCopyNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCopyNoteTesterHelper::copyNoteRequestReady,
        &server,
        &NoteStoreServer::onCopyNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::copyNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->copyNoteAsync(
            noteGuid,
            toNotebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListNoteVersions()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<NoteVersionId> response;
    response << generateRandomNoteVersionId();
    response << generateRandomNoteVersionId();
    response << generateRandomNoteVersionId();

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<NoteVersionId> res = noteStore->listNoteVersions(
        noteGuid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListNoteVersions()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    userException.setParameter(generateRandomString());

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<NoteVersionId> res = noteStore->listNoteVersions(
            noteGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListNoteVersions()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<NoteVersionId> res = noteStore->listNoteVersions(
            noteGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListNoteVersions()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<NoteVersionId> res = noteStore->listNoteVersions(
            noteGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListNoteVersions()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<NoteVersionId> res = noteStore->listNoteVersions(
            noteGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListNoteVersionsAsync()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<NoteVersionId> response;
    response << generateRandomNoteVersionId();
    response << generateRandomNoteVersionId();
    response << generateRandomNoteVersionId();

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listNoteVersionsAsync(
        noteGuid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QList<NoteVersionId>>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListNoteVersionsAsync()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    userException.setParameter(generateRandomString());

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listNoteVersionsAsync(
            noteGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListNoteVersionsAsync()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TAKEN_DOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listNoteVersionsAsync(
            noteGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListNoteVersionsAsync()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listNoteVersionsAsync(
            noteGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListNoteVersionsAsync()
{
    Guid noteGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListNoteVersionsTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             IRequestContextPtr ctxParam) -> QList<NoteVersionId>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequest,
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::onListNoteVersionsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListNoteVersionsTesterHelper::listNoteVersionsRequestReady,
        &server,
        &NoteStoreServer::onListNoteVersionsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listNoteVersionsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listNoteVersionsAsync(
            noteGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNoteVersion()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Note res = noteStore->getNoteVersion(
        noteGuid,
        updateSequenceNum,
        withResourcesData,
        withResourcesRecognition,
        withResourcesAlternateData,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteVersion()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_FEW);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteVersion(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteVersion()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteVersion(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteVersion()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteVersion(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteVersion()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Note res = noteStore->getNoteVersion(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNoteVersionAsync()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Note response = generateRandomNote();

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNoteVersionAsync(
        noteGuid,
        updateSequenceNum,
        withResourcesData,
        withResourcesRecognition,
        withResourcesAlternateData,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Note>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNoteVersionAsync()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    userException.setParameter(generateRandomString());

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteVersionAsync(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNoteVersionAsync()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteVersionAsync(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNoteVersionAsync()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteVersionAsync(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNoteVersionAsync()
{
    Guid noteGuid = generateRandomString();
    qint32 updateSequenceNum = generateRandomInt32();
    bool withResourcesData = generateRandomBool();
    bool withResourcesRecognition = generateRandomBool();
    bool withResourcesAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNoteVersionTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             qint32 updateSequenceNumParam,
             bool withResourcesDataParam,
             bool withResourcesRecognitionParam,
             bool withResourcesAlternateDataParam,
             IRequestContextPtr ctxParam) -> Note
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(updateSequenceNum == updateSequenceNumParam);
            Q_ASSERT(withResourcesData == withResourcesDataParam);
            Q_ASSERT(withResourcesRecognition == withResourcesRecognitionParam);
            Q_ASSERT(withResourcesAlternateData == withResourcesAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequest,
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::onGetNoteVersionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNoteVersionTesterHelper::getNoteVersionRequestReady,
        &server,
        &NoteStoreServer::onGetNoteVersionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNoteVersionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNoteVersionAsync(
            noteGuid,
            updateSequenceNum,
            withResourcesData,
            withResourcesRecognition,
            withResourcesAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResource()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Resource response = generateRandomResource();

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Resource res = noteStore->getResource(
        guid,
        withData,
        withRecognition,
        withAttributes,
        withAlternateData,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResource()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResource(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResource()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResource(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResource()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResource(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResource()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResource(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceAsync()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Resource response = generateRandomResource();

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceAsync(
        guid,
        withData,
        withRecognition,
        withAttributes,
        withAlternateData,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Resource>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceAsync()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAsync(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceAsync()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAsync(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceAsync()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAsync(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceAsync()
{
    Guid guid = generateRandomString();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAttributes = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceTesterHelper helper(
        [&] (const Guid & guidParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAttributesParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAttributes == withAttributesParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequest,
        &helper,
        &NoteStoreGetResourceTesterHelper::onGetResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceTesterHelper::getResourceRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAsync(
            guid,
            withData,
            withRecognition,
            withAttributes,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    LazyMap response = generateRandomLazyMap();

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    LazyMap res = noteStore->getResourceApplicationData(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getResourceApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getResourceApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getResourceApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceApplicationData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LazyMap res = noteStore->getResourceApplicationData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    LazyMap response = generateRandomLazyMap();

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceApplicationDataAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<LazyMap>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TOO_FEW);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceApplicationDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceApplicationDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> LazyMap
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::onGetResourceApplicationDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataTesterHelper::getResourceApplicationDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QString res = noteStore->getResourceApplicationDataEntry(
        guid,
        key,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->getResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceApplicationDataEntryAsync(
        guid,
        key,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QString>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::onGetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceApplicationDataEntryTesterHelper::getResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onGetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteSetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->setResourceApplicationDataEntry(
        guid,
        key,
        value,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInSetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_FEW);
    userException.setParameter(generateRandomString());

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setResourceApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInSetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setResourceApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInSetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setResourceApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInSetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->setResourceApplicationDataEntry(
            guid,
            key,
            value,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteSetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->setResourceApplicationDataEntryAsync(
        guid,
        key,
        value,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInSetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    userException.setParameter(generateRandomString());

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setResourceApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInSetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::RATE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setResourceApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInSetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setResourceApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInSetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    QString value = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreSetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             const QString & valueParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            Q_ASSERT(value == valueParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::onSetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetResourceApplicationDataEntryTesterHelper::setResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onSetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setResourceApplicationDataEntryAsync(
            guid,
            key,
            value,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUnsetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->unsetResourceApplicationDataEntry(
        guid,
        key,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUnsetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUnsetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNKNOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUnsetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUnsetResourceApplicationDataEntry()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->unsetResourceApplicationDataEntry(
            guid,
            key,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUnsetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->unsetResourceApplicationDataEntryAsync(
        guid,
        key,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUnsetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    userException.setParameter(generateRandomString());

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUnsetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUnsetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUnsetResourceApplicationDataEntryAsync()
{
    Guid guid = generateRandomString();
    QString key = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUnsetResourceApplicationDataEntryTesterHelper helper(
        [&] (const Guid & guidParam,
             const QString & keyParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(key == keyParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequest,
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::onUnsetResourceApplicationDataEntryRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUnsetResourceApplicationDataEntryTesterHelper::unsetResourceApplicationDataEntryRequestReady,
        &server,
        &NoteStoreServer::onUnsetResourceApplicationDataEntryRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::unsetResourceApplicationDataEntryRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->unsetResourceApplicationDataEntryAsync(
            guid,
            key,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateResource()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->updateResource(
        resource,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateResource()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateResource(
            resource,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateResource()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateResource(
            resource,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateResource()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateResource(
            resource,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateResource()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateResource(
            resource,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateResourceAsync()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateResourceAsync(
        resource,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateResourceAsync()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateResourceAsync(
            resource,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateResourceAsync()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateResourceAsync(
            resource,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateResourceAsync()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateResourceAsync(
            resource,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateResourceAsync()
{
    Resource resource = generateRandomResource();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateResourceTesterHelper helper(
        [&] (const Resource & resourceParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(resourceParam, resource);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequest,
        &helper,
        &NoteStoreUpdateResourceTesterHelper::onUpdateResourceRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateResourceTesterHelper::updateResourceRequestReady,
        &server,
        &NoteStoreServer::onUpdateResourceRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateResourceRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateResourceAsync(
            resource,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QByteArray response = generateRandomString().toUtf8();

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QByteArray res = noteStore->getResourceData(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_FEW);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QByteArray response = generateRandomString().toUtf8();

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceDataAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QByteArray>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequest,
        &helper,
        &NoteStoreGetResourceDataTesterHelper::onGetResourceDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceDataTesterHelper::getResourceDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceByHash()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Resource response = generateRandomResource();

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Resource res = noteStore->getResourceByHash(
        noteGuid,
        contentHash,
        withData,
        withRecognition,
        withAlternateData,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceByHash()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResourceByHash(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceByHash()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResourceByHash(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceByHash()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResourceByHash(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceByHash()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Resource res = noteStore->getResourceByHash(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceByHashAsync()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Resource response = generateRandomResource();

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceByHashAsync(
        noteGuid,
        contentHash,
        withData,
        withRecognition,
        withAlternateData,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Resource>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceByHashAsync()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNKNOWN);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceByHashAsync(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceByHashAsync()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceByHashAsync(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceByHashAsync()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceByHashAsync(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceByHashAsync()
{
    Guid noteGuid = generateRandomString();
    QByteArray contentHash = generateRandomString().toUtf8();
    bool withData = generateRandomBool();
    bool withRecognition = generateRandomBool();
    bool withAlternateData = generateRandomBool();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceByHashTesterHelper helper(
        [&] (const Guid & noteGuidParam,
             QByteArray contentHashParam,
             bool withDataParam,
             bool withRecognitionParam,
             bool withAlternateDataParam,
             IRequestContextPtr ctxParam) -> Resource
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(noteGuid == noteGuidParam);
            Q_ASSERT(contentHash == contentHashParam);
            Q_ASSERT(withData == withDataParam);
            Q_ASSERT(withRecognition == withRecognitionParam);
            Q_ASSERT(withAlternateData == withAlternateDataParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequest,
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::onGetResourceByHashRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceByHashTesterHelper::getResourceByHashRequestReady,
        &server,
        &NoteStoreServer::onGetResourceByHashRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceByHashRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceByHashAsync(
            noteGuid,
            contentHash,
            withData,
            withRecognition,
            withAlternateData,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceRecognition()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QByteArray response = generateRandomString().toUtf8();

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QByteArray res = noteStore->getResourceRecognition(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceRecognition()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceRecognition(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceRecognition()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceRecognition(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceRecognition()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceRecognition(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceRecognition()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceRecognition(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceRecognitionAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QByteArray response = generateRandomString().toUtf8();

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceRecognitionAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QByteArray>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceRecognitionAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceRecognitionAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceRecognitionAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceRecognitionAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceRecognitionAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceRecognitionAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceRecognitionAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceRecognitionTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequest,
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::onGetResourceRecognitionRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceRecognitionTesterHelper::getResourceRecognitionRequestReady,
        &server,
        &NoteStoreServer::onGetResourceRecognitionRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceRecognitionRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceRecognitionAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceAlternateData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QByteArray response = generateRandomString().toUtf8();

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QByteArray res = noteStore->getResourceAlternateData(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceAlternateData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceAlternateData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceAlternateData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceAlternateData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceAlternateData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceAlternateData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceAlternateData()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QByteArray res = noteStore->getResourceAlternateData(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceAlternateDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QByteArray response = generateRandomString().toUtf8();

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceAlternateDataAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QByteArray>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceAlternateDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAlternateDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceAlternateDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAlternateDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceAlternateDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAlternateDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceAlternateDataAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceAlternateDataTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QByteArray
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequest,
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::onGetResourceAlternateDataRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAlternateDataTesterHelper::getResourceAlternateDataRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAlternateDataRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAlternateDataRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAlternateDataAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetResourceAttributes()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    ResourceAttributes response = generateRandomResourceAttributes();

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    ResourceAttributes res = noteStore->getResourceAttributes(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceAttributes()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ResourceAttributes res = noteStore->getResourceAttributes(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceAttributes()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ResourceAttributes res = noteStore->getResourceAttributes(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceAttributes()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ResourceAttributes res = noteStore->getResourceAttributes(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceAttributes()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ResourceAttributes res = noteStore->getResourceAttributes(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetResourceAttributesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    ResourceAttributes response = generateRandomResourceAttributes();

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getResourceAttributesAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<ResourceAttributes>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetResourceAttributesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    userException.setParameter(generateRandomString());

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAttributesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetResourceAttributesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAttributesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetResourceAttributesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAttributesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetResourceAttributesAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetResourceAttributesTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> ResourceAttributes
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequest,
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::onGetResourceAttributesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetResourceAttributesTesterHelper::getResourceAttributesRequestReady,
        &server,
        &NoteStoreServer::onGetResourceAttributesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getResourceAttributesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getResourceAttributesAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetPublicNotebook()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    Notebook response = generateRandomNotebook();

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Notebook res = noteStore->getPublicNotebook(
        userId,
        publicUri,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetPublicNotebook()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getPublicNotebook(
            userId,
            publicUri,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetPublicNotebook()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getPublicNotebook(
            userId,
            publicUri,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetPublicNotebook()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->getPublicNotebook(
            userId,
            publicUri,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetPublicNotebookAsync()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    Notebook response = generateRandomNotebook();

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getPublicNotebookAsync(
        userId,
        publicUri,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Notebook>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetPublicNotebookAsync()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getPublicNotebookAsync(
            userId,
            publicUri,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetPublicNotebookAsync()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getPublicNotebookAsync(
            userId,
            publicUri,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetPublicNotebookAsync()
{
    UserID userId = generateRandomInt32();
    QString publicUri = generateRandomString();
    IRequestContextPtr ctx = newRequestContext();

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetPublicNotebookTesterHelper helper(
        [&] (const UserID & userIdParam,
             const QString & publicUriParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(userId == userIdParam);
            Q_ASSERT(publicUri == publicUriParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequest,
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::onGetPublicNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetPublicNotebookTesterHelper::getPublicNotebookRequestReady,
        &server,
        &NoteStoreServer::onGetPublicNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getPublicNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getPublicNotebookAsync(
            userId,
            publicUri,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteShareNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SharedNotebook response = generateRandomSharedNotebook();

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SharedNotebook res = noteStore->shareNotebook(
        sharedNotebook,
        message,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInShareNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    userException.setParameter(generateRandomString());

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->shareNotebook(
            sharedNotebook,
            message,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInShareNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->shareNotebook(
            sharedNotebook,
            message,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInShareNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->shareNotebook(
            sharedNotebook,
            message,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInShareNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->shareNotebook(
            sharedNotebook,
            message,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteShareNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SharedNotebook response = generateRandomSharedNotebook();

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->shareNotebookAsync(
        sharedNotebook,
        message,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<SharedNotebook>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInShareNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNotebookAsync(
            sharedNotebook,
            message,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInShareNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNotebookAsync(
            sharedNotebook,
            message,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInShareNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNotebookAsync(
            sharedNotebook,
            message,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInShareNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    QString message = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreShareNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             const QString & messageParam,
             IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            Q_ASSERT(message == messageParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequest,
        &helper,
        &NoteStoreShareNotebookTesterHelper::onShareNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNotebookTesterHelper::shareNotebookRequestReady,
        &server,
        &NoteStoreServer::onShareNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNotebookAsync(
            sharedNotebook,
            message,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteCreateOrUpdateNotebookShares()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    CreateOrUpdateNotebookSharesResult response = generateRandomCreateOrUpdateNotebookSharesResult();

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    CreateOrUpdateNotebookSharesResult res = noteStore->createOrUpdateNotebookShares(
        shareTemplate,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateOrUpdateNotebookShares()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        CreateOrUpdateNotebookSharesResult res = noteStore->createOrUpdateNotebookShares(
            shareTemplate,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateOrUpdateNotebookShares()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        CreateOrUpdateNotebookSharesResult res = noteStore->createOrUpdateNotebookShares(
            shareTemplate,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateOrUpdateNotebookShares()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        CreateOrUpdateNotebookSharesResult res = noteStore->createOrUpdateNotebookShares(
            shareTemplate,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMInvalidContactsExceptionInCreateOrUpdateNotebookShares()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto invalidContactsException = EDAMInvalidContactsException();
    invalidContactsException.mutableContacts().push_back(generateRandomContact());
    invalidContactsException.mutableContacts().push_back(generateRandomContact());
    invalidContactsException.mutableContacts().push_back(generateRandomContact());
    invalidContactsException.setParameter(generateRandomString());
    invalidContactsException.setReasons(QList<EDAMInvalidContactReason>());
    invalidContactsException.mutableReasons()->push_back(EDAMInvalidContactReason::DUPLICATE_CONTACT);
    invalidContactsException.mutableReasons()->push_back(EDAMInvalidContactReason::NO_CONNECTION);
    invalidContactsException.mutableReasons()->push_back(EDAMInvalidContactReason::NO_CONNECTION);

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw invalidContactsException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        CreateOrUpdateNotebookSharesResult res = noteStore->createOrUpdateNotebookShares(
            shareTemplate,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMInvalidContactsException & e)
    {
        caughtException = true;
        QVERIFY(e == invalidContactsException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateOrUpdateNotebookShares()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        CreateOrUpdateNotebookSharesResult res = noteStore->createOrUpdateNotebookShares(
            shareTemplate,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteCreateOrUpdateNotebookSharesAsync()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    CreateOrUpdateNotebookSharesResult response = generateRandomCreateOrUpdateNotebookSharesResult();

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->createOrUpdateNotebookSharesAsync(
        shareTemplate,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<CreateOrUpdateNotebookSharesResult>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateOrUpdateNotebookSharesAsync()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    userException.setParameter(generateRandomString());

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createOrUpdateNotebookSharesAsync(
            shareTemplate,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateOrUpdateNotebookSharesAsync()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createOrUpdateNotebookSharesAsync(
            shareTemplate,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateOrUpdateNotebookSharesAsync()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TAKEN_DOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createOrUpdateNotebookSharesAsync(
            shareTemplate,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMInvalidContactsExceptionInCreateOrUpdateNotebookSharesAsync()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto invalidContactsException = EDAMInvalidContactsException();
    invalidContactsException.mutableContacts().push_back(generateRandomContact());
    invalidContactsException.mutableContacts().push_back(generateRandomContact());
    invalidContactsException.mutableContacts().push_back(generateRandomContact());
    invalidContactsException.setParameter(generateRandomString());
    invalidContactsException.setReasons(QList<EDAMInvalidContactReason>());
    invalidContactsException.mutableReasons()->push_back(EDAMInvalidContactReason::DUPLICATE_CONTACT);
    invalidContactsException.mutableReasons()->push_back(EDAMInvalidContactReason::BAD_ADDRESS);
    invalidContactsException.mutableReasons()->push_back(EDAMInvalidContactReason::DUPLICATE_CONTACT);

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw invalidContactsException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createOrUpdateNotebookSharesAsync(
            shareTemplate,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMInvalidContactsException & e)
    {
        caughtException = true;
        QVERIFY(e == invalidContactsException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateOrUpdateNotebookSharesAsync()
{
    NotebookShareTemplate shareTemplate = generateRandomNotebookShareTemplate();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateOrUpdateNotebookSharesTesterHelper helper(
        [&] (const NotebookShareTemplate & shareTemplateParam,
             IRequestContextPtr ctxParam) -> CreateOrUpdateNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(shareTemplate == shareTemplateParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequest,
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::onCreateOrUpdateNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateOrUpdateNotebookSharesTesterHelper::createOrUpdateNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onCreateOrUpdateNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createOrUpdateNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createOrUpdateNotebookSharesAsync(
            shareTemplate,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateSharedNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->updateSharedNotebook(
        sharedNotebook,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateSharedNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSharedNotebook(
            sharedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateSharedNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSharedNotebook(
            sharedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateSharedNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSharedNotebook(
            sharedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateSharedNotebook()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateSharedNotebook(
            sharedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateSharedNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateSharedNotebookAsync(
        sharedNotebook,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateSharedNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSharedNotebookAsync(
            sharedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateSharedNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSharedNotebookAsync(
            sharedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateSharedNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSharedNotebookAsync(
            sharedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateSharedNotebookAsync()
{
    SharedNotebook sharedNotebook = generateRandomSharedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateSharedNotebookTesterHelper helper(
        [&] (const SharedNotebook & sharedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(sharedNotebook == sharedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequest,
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::onUpdateSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateSharedNotebookTesterHelper::updateSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateSharedNotebookAsync(
            sharedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteSetNotebookRecipientSettings()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    Notebook res = noteStore->setNotebookRecipientSettings(
        notebookGuid,
        recipientSettings,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInSetNotebookRecipientSettings()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_FEW);
    userException.setParameter(generateRandomString());

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->setNotebookRecipientSettings(
            notebookGuid,
            recipientSettings,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInSetNotebookRecipientSettings()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->setNotebookRecipientSettings(
            notebookGuid,
            recipientSettings,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInSetNotebookRecipientSettings()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->setNotebookRecipientSettings(
            notebookGuid,
            recipientSettings,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInSetNotebookRecipientSettings()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        Notebook res = noteStore->setNotebookRecipientSettings(
            notebookGuid,
            recipientSettings,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteSetNotebookRecipientSettingsAsync()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    Notebook response = generateRandomNotebook();

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->setNotebookRecipientSettingsAsync(
        notebookGuid,
        recipientSettings,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<Notebook>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInSetNotebookRecipientSettingsAsync()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNKNOWN);
    userException.setParameter(generateRandomString());

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNotebookRecipientSettingsAsync(
            notebookGuid,
            recipientSettings,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInSetNotebookRecipientSettingsAsync()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNotebookRecipientSettingsAsync(
            notebookGuid,
            recipientSettings,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInSetNotebookRecipientSettingsAsync()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNotebookRecipientSettingsAsync(
            notebookGuid,
            recipientSettings,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInSetNotebookRecipientSettingsAsync()
{
    QString notebookGuid = generateRandomString();
    NotebookRecipientSettings recipientSettings = generateRandomNotebookRecipientSettings();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreSetNotebookRecipientSettingsTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             const NotebookRecipientSettings & recipientSettingsParam,
             IRequestContextPtr ctxParam) -> Notebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            Q_ASSERT(recipientSettings == recipientSettingsParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequest,
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::onSetNotebookRecipientSettingsRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreSetNotebookRecipientSettingsTesterHelper::setNotebookRecipientSettingsRequestReady,
        &server,
        &NoteStoreServer::onSetNotebookRecipientSettingsRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::setNotebookRecipientSettingsRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->setNotebookRecipientSettingsAsync(
            notebookGuid,
            recipientSettings,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListSharedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<SharedNotebook> response;
    response << generateRandomSharedNotebook();
    response << generateRandomSharedNotebook();
    response << generateRandomSharedNotebook();

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<SharedNotebook> res = noteStore->listSharedNotebooks(
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListSharedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    userException.setParameter(generateRandomString());

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<SharedNotebook> res = noteStore->listSharedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListSharedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<SharedNotebook> res = noteStore->listSharedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListSharedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<SharedNotebook> res = noteStore->listSharedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListSharedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<SharedNotebook> res = noteStore->listSharedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListSharedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<SharedNotebook> response;
    response << generateRandomSharedNotebook();
    response << generateRandomSharedNotebook();
    response << generateRandomSharedNotebook();

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listSharedNotebooksAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QList<SharedNotebook>>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListSharedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listSharedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListSharedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listSharedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListSharedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BUSINESS_SECURITY_LOGIN_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listSharedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListSharedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListSharedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<SharedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequest,
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::onListSharedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListSharedNotebooksTesterHelper::listSharedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListSharedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listSharedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listSharedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteCreateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    LinkedNotebook response = generateRandomLinkedNotebook();

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    LinkedNotebook res = noteStore->createLinkedNotebook(
        linkedNotebook,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    userException.setParameter(generateRandomString());

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LinkedNotebook res = noteStore->createLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LinkedNotebook res = noteStore->createLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TOO_MANY);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LinkedNotebook res = noteStore->createLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        LinkedNotebook res = noteStore->createLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteCreateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    LinkedNotebook response = generateRandomLinkedNotebook();

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->createLinkedNotebookAsync(
        linkedNotebook,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<LinkedNotebook>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInCreateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    userException.setParameter(generateRandomString());

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInCreateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInCreateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInCreateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreCreateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> LinkedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequest,
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::onCreateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreCreateLinkedNotebookTesterHelper::createLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onCreateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::createLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->createLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->updateLinkedNotebook(
        linkedNotebook,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::OPENID_ALREADY_TAKEN);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateLinkedNotebook()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->updateLinkedNotebook(
            linkedNotebook,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateLinkedNotebookAsync(
        linkedNotebook,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::UNSUPPORTED_OPERATION);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateLinkedNotebookAsync()
{
    LinkedNotebook linkedNotebook = generateRandomLinkedNotebook();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateLinkedNotebookTesterHelper helper(
        [&] (const LinkedNotebook & linkedNotebookParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(linkedNotebook == linkedNotebookParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequest,
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::onUpdateLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateLinkedNotebookTesterHelper::updateLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onUpdateLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateLinkedNotebookAsync(
            linkedNotebook,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteListLinkedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<LinkedNotebook> response;
    response << generateRandomLinkedNotebook();
    response << generateRandomLinkedNotebook();
    response << generateRandomLinkedNotebook();

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QList<LinkedNotebook> res = noteStore->listLinkedNotebooks(
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListLinkedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_FEW);
    userException.setParameter(generateRandomString());

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<LinkedNotebook> res = noteStore->listLinkedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListLinkedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<LinkedNotebook> res = noteStore->listLinkedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListLinkedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<LinkedNotebook> res = noteStore->listLinkedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListLinkedNotebooks()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QList<LinkedNotebook> res = noteStore->listLinkedNotebooks(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteListLinkedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QList<LinkedNotebook> response;
    response << generateRandomLinkedNotebook();
    response << generateRandomLinkedNotebook();
    response << generateRandomLinkedNotebook();

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->listLinkedNotebooksAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QList<LinkedNotebook>>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInListLinkedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    userException.setParameter(generateRandomString());

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listLinkedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInListLinkedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listLinkedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInListLinkedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listLinkedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInListLinkedNotebooksAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreListLinkedNotebooksTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> QList<LinkedNotebook>
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequest,
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::onListLinkedNotebooksRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreListLinkedNotebooksTesterHelper::listLinkedNotebooksRequestReady,
        &server,
        &NoteStoreServer::onListLinkedNotebooksRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::listLinkedNotebooksRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->listLinkedNotebooksAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteExpungeLinkedNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    qint32 res = noteStore->expungeLinkedNotebook(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeLinkedNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeLinkedNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeLinkedNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeLinkedNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeLinkedNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeLinkedNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeLinkedNotebook()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        qint32 res = noteStore->expungeLinkedNotebook(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteExpungeLinkedNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    qint32 response = generateRandomInt32();

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->expungeLinkedNotebookAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<qint32>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInExpungeLinkedNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::RATE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeLinkedNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInExpungeLinkedNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeLinkedNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInExpungeLinkedNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeLinkedNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInExpungeLinkedNotebookAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreExpungeLinkedNotebookTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> qint32
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequest,
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::onExpungeLinkedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreExpungeLinkedNotebookTesterHelper::expungeLinkedNotebookRequestReady,
        &server,
        &NoteStoreServer::onExpungeLinkedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::expungeLinkedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->expungeLinkedNotebookAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteAuthenticateToSharedNotebook()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    AuthenticationResult response = generateRandomAuthenticationResult();

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    AuthenticationResult res = noteStore->authenticateToSharedNotebook(
        shareKeyOrGlobalId,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInAuthenticateToSharedNotebook()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_OPENID_TOKEN);
    userException.setParameter(generateRandomString());

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNotebook(
            shareKeyOrGlobalId,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInAuthenticateToSharedNotebook()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNotebook(
            shareKeyOrGlobalId,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInAuthenticateToSharedNotebook()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNotebook(
            shareKeyOrGlobalId,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInAuthenticateToSharedNotebook()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNotebook(
            shareKeyOrGlobalId,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteAuthenticateToSharedNotebookAsync()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    AuthenticationResult response = generateRandomAuthenticationResult();

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->authenticateToSharedNotebookAsync(
        shareKeyOrGlobalId,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<AuthenticationResult>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInAuthenticateToSharedNotebookAsync()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNotebookAsync(
            shareKeyOrGlobalId,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInAuthenticateToSharedNotebookAsync()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNotebookAsync(
            shareKeyOrGlobalId,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInAuthenticateToSharedNotebookAsync()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNotebookAsync(
            shareKeyOrGlobalId,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInAuthenticateToSharedNotebookAsync()
{
    QString shareKeyOrGlobalId = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreAuthenticateToSharedNotebookTesterHelper helper(
        [&] (const QString & shareKeyOrGlobalIdParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(shareKeyOrGlobalId == shareKeyOrGlobalIdParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::onAuthenticateToSharedNotebookRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNotebookTesterHelper::authenticateToSharedNotebookRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNotebookRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNotebookRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNotebookAsync(
            shareKeyOrGlobalId,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetSharedNotebookByAuth()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SharedNotebook response = generateRandomSharedNotebook();

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    SharedNotebook res = noteStore->getSharedNotebookByAuth(
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetSharedNotebookByAuth()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    userException.setParameter(generateRandomString());

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->getSharedNotebookByAuth(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetSharedNotebookByAuth()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->getSharedNotebookByAuth(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetSharedNotebookByAuth()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->getSharedNotebookByAuth(
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetSharedNotebookByAuth()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        SharedNotebook res = noteStore->getSharedNotebookByAuth(
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetSharedNotebookByAuthAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    SharedNotebook response = generateRandomSharedNotebook();

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getSharedNotebookByAuthAsync(
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<SharedNotebook>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetSharedNotebookByAuthAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LEN_TOO_SHORT);
    userException.setParameter(generateRandomString());

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSharedNotebookByAuthAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetSharedNotebookByAuthAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSharedNotebookByAuthAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetSharedNotebookByAuthAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNKNOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSharedNotebookByAuthAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetSharedNotebookByAuthAsync()
{
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetSharedNotebookByAuthTesterHelper helper(
        [&] (IRequestContextPtr ctxParam) -> SharedNotebook
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequest,
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::onGetSharedNotebookByAuthRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetSharedNotebookByAuthTesterHelper::getSharedNotebookByAuthRequestReady,
        &server,
        &NoteStoreServer::onGetSharedNotebookByAuthRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getSharedNotebookByAuthRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getSharedNotebookByAuthAsync(
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteEmailNote()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            return;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    noteStore->emailNote(
        parameters,
        ctx);

}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInEmailNote()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->emailNote(
            parameters,
            ctx);

    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInEmailNote()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->emailNote(
            parameters,
            ctx);

    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInEmailNote()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_REGISTERED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->emailNote(
            parameters,
            ctx);

    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInEmailNote()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->emailNote(
            parameters,
            ctx);

    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteEmailNoteAsync()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            return;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->emailNoteAsync(
        parameters,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInEmailNoteAsync()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::AUTH_EXPIRED);
    userException.setParameter(generateRandomString());

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->emailNoteAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInEmailNoteAsync()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->emailNoteAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInEmailNoteAsync()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BAD_DATA_FORMAT);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->emailNoteAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInEmailNoteAsync()
{
    NoteEmailParameters parameters = generateRandomNoteEmailParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreEmailNoteTesterHelper helper(
        [&] (const NoteEmailParameters & parametersParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(parametersParam, parameters);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequest,
        &helper,
        &NoteStoreEmailNoteTesterHelper::onEmailNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreEmailNoteTesterHelper::emailNoteRequestReady,
        &server,
        &NoteStoreServer::onEmailNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::emailNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->emailNoteAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteShareNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QString res = noteStore->shareNote(
        guid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInShareNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->shareNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInShareNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->shareNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInShareNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TOO_MANY);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->shareNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInShareNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QString res = noteStore->shareNote(
            guid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteShareNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    QString response = generateRandomString();

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->shareNoteAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<QString>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInShareNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInShareNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInShareNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInShareNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreShareNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> QString
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequest,
        &helper,
        &NoteStoreShareNoteTesterHelper::onShareNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreShareNoteTesterHelper::shareNoteRequestReady,
        &server,
        &NoteStoreServer::onShareNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::shareNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->shareNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteStopSharingNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    noteStore->stopSharingNote(
        guid,
        ctx);

}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInStopSharingNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::PERMISSION_DENIED);
    userException.setParameter(generateRandomString());

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->stopSharingNote(
            guid,
            ctx);

    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInStopSharingNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->stopSharingNote(
            guid,
            ctx);

    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInStopSharingNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::TAKEN_DOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->stopSharingNote(
            guid,
            ctx);

    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInStopSharingNote()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        noteStore->stopSharingNote(
            guid,
            ctx);

    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteStopSharingNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            return;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->stopSharingNoteAsync(
        guid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInStopSharingNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::RATE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->stopSharingNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInStopSharingNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->stopSharingNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInStopSharingNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->stopSharingNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInStopSharingNoteAsync()
{
    Guid guid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreStopSharingNoteTesterHelper helper(
        [&] (const Guid & guidParam,
             IRequestContextPtr ctxParam) -> void
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(guid == guidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequest,
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::onStopSharingNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreStopSharingNoteTesterHelper::stopSharingNoteRequestReady,
        &server,
        &NoteStoreServer::onStopSharingNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::stopSharingNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->stopSharingNoteAsync(
            guid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteAuthenticateToSharedNote()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    AuthenticationResult response = generateRandomAuthenticationResult();

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    AuthenticationResult res = noteStore->authenticateToSharedNote(
        guid,
        noteKey,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInAuthenticateToSharedNote()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::TOO_FEW);
    userException.setParameter(generateRandomString());

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNote(
            guid,
            noteKey,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInAuthenticateToSharedNote()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNote(
            guid,
            noteKey,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInAuthenticateToSharedNote()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::RATE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNote(
            guid,
            noteKey,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInAuthenticateToSharedNote()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        AuthenticationResult res = noteStore->authenticateToSharedNote(
            guid,
            noteKey,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteAuthenticateToSharedNoteAsync()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    AuthenticationResult response = generateRandomAuthenticationResult();

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->authenticateToSharedNoteAsync(
        guid,
        noteKey,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<AuthenticationResult>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInAuthenticateToSharedNoteAsync()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::QUOTA_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNoteAsync(
            guid,
            noteKey,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInAuthenticateToSharedNoteAsync()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNoteAsync(
            guid,
            noteKey,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInAuthenticateToSharedNoteAsync()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::UNKNOWN);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNoteAsync(
            guid,
            noteKey,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInAuthenticateToSharedNoteAsync()
{
    QString guid = generateRandomString();
    QString noteKey = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreAuthenticateToSharedNoteTesterHelper helper(
        [&] (const QString & guidParam,
             const QString & noteKeyParam,
             IRequestContextPtr ctxParam) -> AuthenticationResult
        {
            Q_ASSERT(guid == guidParam);
            Q_ASSERT(noteKey == noteKeyParam);
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequest,
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::onAuthenticateToSharedNoteRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreAuthenticateToSharedNoteTesterHelper::authenticateToSharedNoteRequestReady,
        &server,
        &NoteStoreServer::onAuthenticateToSharedNoteRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::authenticateToSharedNoteRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->authenticateToSharedNoteAsync(
            guid,
            noteKey,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteFindRelated()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    RelatedResult response = generateRandomRelatedResult();

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    RelatedResult res = noteStore->findRelated(
        query,
        resultSpec,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindRelated()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INTERNAL_ERROR);
    userException.setParameter(generateRandomString());

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        RelatedResult res = noteStore->findRelated(
            query,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindRelated()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        RelatedResult res = noteStore->findRelated(
            query,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindRelated()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        RelatedResult res = noteStore->findRelated(
            query,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindRelated()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        RelatedResult res = noteStore->findRelated(
            query,
            resultSpec,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteFindRelatedAsync()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    RelatedResult response = generateRandomRelatedResult();

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->findRelatedAsync(
        query,
        resultSpec,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<RelatedResult>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInFindRelatedAsync()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DATA_CONFLICT);
    userException.setParameter(generateRandomString());

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findRelatedAsync(
            query,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInFindRelatedAsync()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ACCOUNT_CLEAR);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findRelatedAsync(
            query,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInFindRelatedAsync()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findRelatedAsync(
            query,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInFindRelatedAsync()
{
    RelatedQuery query = generateRandomRelatedQuery();
    RelatedResultSpec resultSpec = generateRandomRelatedResultSpec();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreFindRelatedTesterHelper helper(
        [&] (const RelatedQuery & queryParam,
             const RelatedResultSpec & resultSpecParam,
             IRequestContextPtr ctxParam) -> RelatedResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(query == queryParam);
            Q_ASSERT(resultSpec == resultSpecParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequest,
        &helper,
        &NoteStoreFindRelatedTesterHelper::onFindRelatedRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreFindRelatedTesterHelper::findRelatedRequestReady,
        &server,
        &NoteStoreServer::onFindRelatedRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::findRelatedRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->findRelatedAsync(
            query,
            resultSpec,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteUpdateNoteIfUsnMatches()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    UpdateNoteIfUsnMatchesResult response = generateRandomUpdateNoteIfUsnMatchesResult();

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    UpdateNoteIfUsnMatchesResult res = noteStore->updateNoteIfUsnMatches(
        note,
        ctx);

    compareValuesWithoutLocalIds(res, response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateNoteIfUsnMatches()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        UpdateNoteIfUsnMatchesResult res = noteStore->updateNoteIfUsnMatches(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateNoteIfUsnMatches()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        UpdateNoteIfUsnMatchesResult res = noteStore->updateNoteIfUsnMatches(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateNoteIfUsnMatches()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::SHARD_UNAVAILABLE);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        UpdateNoteIfUsnMatchesResult res = noteStore->updateNoteIfUsnMatches(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateNoteIfUsnMatches()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        UpdateNoteIfUsnMatchesResult res = noteStore->updateNoteIfUsnMatches(
            note,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteUpdateNoteIfUsnMatchesAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    UpdateNoteIfUsnMatchesResult response = generateRandomUpdateNoteIfUsnMatchesResult();

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->updateNoteIfUsnMatchesAsync(
        note,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    compareValuesWithoutLocalIds(qvariant_cast<UpdateNoteIfUsnMatchesResult>(result.result()), response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInUpdateNoteIfUsnMatchesAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::SSO_AUTHENTICATION_REQUIRED);
    userException.setParameter(generateRandomString());

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteIfUsnMatchesAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInUpdateNoteIfUsnMatchesAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteIfUsnMatchesAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInUpdateNoteIfUsnMatchesAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::LEN_TOO_LONG);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteIfUsnMatchesAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInUpdateNoteIfUsnMatchesAsync()
{
    Note note = generateRandomNote();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreUpdateNoteIfUsnMatchesTesterHelper helper(
        [&] (const Note & noteParam,
             IRequestContextPtr ctxParam) -> UpdateNoteIfUsnMatchesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            compareValuesWithoutLocalIds(noteParam, note);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequest,
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::onUpdateNoteIfUsnMatchesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreUpdateNoteIfUsnMatchesTesterHelper::updateNoteIfUsnMatchesRequestReady,
        &server,
        &NoteStoreServer::onUpdateNoteIfUsnMatchesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::updateNoteIfUsnMatchesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->updateNoteIfUsnMatchesAsync(
            note,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteManageNotebookShares()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    ManageNotebookSharesResult response = generateRandomManageNotebookSharesResult();

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    ManageNotebookSharesResult res = noteStore->manageNotebookShares(
        parameters,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInManageNotebookShares()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::INVALID_AUTH);
    userException.setParameter(generateRandomString());

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ManageNotebookSharesResult res = noteStore->manageNotebookShares(
            parameters,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInManageNotebookShares()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ManageNotebookSharesResult res = noteStore->manageNotebookShares(
            parameters,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInManageNotebookShares()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::ENML_VALIDATION);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ManageNotebookSharesResult res = noteStore->manageNotebookShares(
            parameters,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInManageNotebookShares()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ManageNotebookSharesResult res = noteStore->manageNotebookShares(
            parameters,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteManageNotebookSharesAsync()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    ManageNotebookSharesResult response = generateRandomManageNotebookSharesResult();

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->manageNotebookSharesAsync(
        parameters,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<ManageNotebookSharesResult>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInManageNotebookSharesAsync()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::USER_NOT_ASSOCIATED);
    userException.setParameter(generateRandomString());

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->manageNotebookSharesAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInManageNotebookSharesAsync()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->manageNotebookSharesAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInManageNotebookSharesAsync()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->manageNotebookSharesAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInManageNotebookSharesAsync()
{
    ManageNotebookSharesParameters parameters = generateRandomManageNotebookSharesParameters();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreManageNotebookSharesTesterHelper helper(
        [&] (const ManageNotebookSharesParameters & parametersParam,
             IRequestContextPtr ctxParam) -> ManageNotebookSharesResult
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(parameters == parametersParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequest,
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::onManageNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreManageNotebookSharesTesterHelper::manageNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onManageNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::manageNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->manageNotebookSharesAsync(
            parameters,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

////////////////////////////////////////////////////////////////////////////////

void NoteStoreTester::shouldExecuteGetNotebookShares()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    ShareRelationships response = generateRandomShareRelationships();

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    ShareRelationships res = noteStore->getNotebookShares(
        notebookGuid,
        ctx);

    QVERIFY(res == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNotebookShares()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ShareRelationships res = noteStore->getNotebookShares(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNotebookShares()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ShareRelationships res = noteStore->getNotebookShares(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNotebookShares()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::BUSINESS_SECURITY_LOGIN_REQUIRED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ShareRelationships res = noteStore->getNotebookShares(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNotebookShares()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        ShareRelationships res = noteStore->getNotebookShares(
            notebookGuid,
            ctx);

        Q_UNUSED(res)
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldExecuteGetNotebookSharesAsync()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    ShareRelationships response = generateRandomShareRelationships();

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            return response;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    QFuture<QVariant> result = noteStore->getNotebookSharesAsync(
        notebookGuid,
        ctx);

    QFutureWatcher<QVariant> watcher;
    QEventLoop loop;
    QObject::connect(
        &watcher, &QFutureWatcher<QVariant>::finished, &loop,
        &QEventLoop::quit);

    watcher.setFuture(result);
    loop.exec();

    QVERIFY(qvariant_cast<ShareRelationships>(result.result()) == response);
}

void NoteStoreTester::shouldDeliverEDAMUserExceptionInGetNotebookSharesAsync()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto userException = EDAMUserException();
    userException.setErrorCode(EDAMErrorCode::DEVICE_LIMIT_REACHED);
    userException.setParameter(generateRandomString());

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw userException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookSharesAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMUserException & e)
    {
        caughtException = true;
        QVERIFY(e == userException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMNotFoundExceptionInGetNotebookSharesAsync()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto notFoundException = EDAMNotFoundException();
    notFoundException.setIdentifier(generateRandomString());
    notFoundException.setKey(generateRandomString());

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw notFoundException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookSharesAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMNotFoundException & e)
    {
        caughtException = true;
        QVERIFY(e == notFoundException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverEDAMSystemExceptionInGetNotebookSharesAsync()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto systemException = EDAMSystemException();
    systemException.setErrorCode(EDAMErrorCode::USER_ALREADY_ASSOCIATED);
    systemException.setMessage(generateRandomString());
    systemException.setRateLimitDuration(generateRandomInt32());

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw systemException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookSharesAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const EDAMSystemException & e)
    {
        caughtException = true;
        QVERIFY(e == systemException);
    }

    QVERIFY(caughtException);
}

void NoteStoreTester::shouldDeliverThriftExceptionInGetNotebookSharesAsync()
{
    QString notebookGuid = generateRandomString();
    IRequestContextPtr ctx = newRequestContext(
        QStringLiteral("authenticationToken"));

    auto thriftException = ThriftException(
        ThriftException::Type::INTERNAL_ERROR,
        QStringLiteral("Internal error"));

    NoteStoreGetNotebookSharesTesterHelper helper(
        [&] (const QString & notebookGuidParam,
             IRequestContextPtr ctxParam) -> ShareRelationships
        {
            Q_ASSERT(ctx->authenticationToken() == ctxParam->authenticationToken());
            Q_ASSERT(notebookGuid == notebookGuidParam);
            throw thriftException;
        });

    NoteStoreServer server;
    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequest,
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::onGetNotebookSharesRequestReceived);
    QObject::connect(
        &helper,
        &NoteStoreGetNotebookSharesTesterHelper::getNotebookSharesRequestReady,
        &server,
        &NoteStoreServer::onGetNotebookSharesRequestReady);

    QTcpServer tcpServer;
    QVERIFY(tcpServer.listen(QHostAddress::LocalHost));
    quint16 port = tcpServer.serverPort();

    QTcpSocket * pSocket = nullptr;
    QObject::connect(
        &tcpServer,
        &QTcpServer::newConnection,
        &tcpServer,
        [&] {
            pSocket = tcpServer.nextPendingConnection();
            Q_ASSERT(pSocket);
            QObject::connect(
                pSocket,
                &QAbstractSocket::disconnected,
                pSocket,
                &QAbstractSocket::deleteLater);
            if (!pSocket->waitForConnected()) {
                QFAIL("Failed to establish connection");
            }

            QByteArray requestData = readThriftRequestFromSocket(*pSocket);
            server.onRequest(requestData);
        });

    QObject::connect(
        &server,
        &NoteStoreServer::getNotebookSharesRequestReady,
        &server,
        [&] (QByteArray responseData)
        {
            QByteArray buffer;
            buffer.append("HTTP/1.1 200 OK\r\n");
            buffer.append("Content-Length: ");
            buffer.append(QString::number(responseData.size()).toUtf8());
            buffer.append("\r\n");
            buffer.append("Content-Type: application/x-thrift\r\n\r\n");
            buffer.append(responseData);

            if (!writeBufferToSocket(buffer, *pSocket)) {
                QFAIL("Failed to write response to socket");
            }
        });

    std::unique_ptr<INoteStore> noteStore(
        newNoteStore(
            QStringLiteral("http://127.0.0.1:") + QString::number(port),
            QString{},
            nullptr,
            nullptr,
            nullRetryPolicy()));

    bool caughtException = false;
    try
    {
        QFuture<QVariant> result = noteStore->getNotebookSharesAsync(
            notebookGuid,
            ctx);

        QFutureWatcher<QVariant> watcher;
        QEventLoop loop;
        QObject::connect(
                &watcher, &QFutureWatcher<QVariant>::finished, &loop,
                &QEventLoop::quit);

        watcher.setFuture(result);
        loop.exec();

        result.waitForFinished();
    }
    catch(const ThriftException & e)
    {
        caughtException = true;
        QVERIFY(e == thriftException);
    }

    QVERIFY(caughtException);
}

} // namespace qevercloud

#include <TestNoteStore.moc>
